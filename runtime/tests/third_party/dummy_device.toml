schema = 2

[operators.gates.native]

QubitUnitary = { controllable = true }
PauliX = { controllable = true }
PauliY = { controllable = true }
PauliZ = { controllable = true }
MultiRZ = { controllable = true }
Hadamard = { controllable = true }
S = { controllable = true }
T = { controllable = true }
CNOT = { }
SWAP = { controllable = true }
CSWAP = { }
Toffoli = { controllable = true }
CY = { }
CZ = { }
PhaseShift = { controllable = true }
ControlledPhaseShift = { }
RX = { controllable = true }
RY = { controllable = true }
RZ = { controllable = true }
Rot = { controllable = true }
CRX = { }
CRY = { }
CRZ = { }
CRot = { }
Identity = { controllable = true }
IsingXX = { controllable = true }
IsingYY = { controllable = true }
IsingZZ = { controllable = true }
IsingXY = { controllable = true }

[operators.gates.decomp]

# Operators that should be decomposed according to the algorithm used
# by PennyLane's device API.
# Optional, since gates not listed in this list will typically be decomposed by
# default, but can be useful to express a deviation from this device's regular
# strategy in PennyLane.
SX = {}
ISWAP = {}
PSWAP = {}
SISWAP = {}
SQISW = {}
CPhase = {}
BasisState = {}
QubitStateVector = {}
StatePrep = {}
ControlledQubitUnitary = {}
DiagonalQubitUnitary = {}
SingleExcitation = {}
SingleExcitationPlus = {}
SingleExcitationMinus = {}
DoubleExcitation = {}
DoubleExcitationPlus = {}
DoubleExcitationMinus = {}
QubitCarry = {}
QubitSum = {}
OrbitalRotation = {}
QFT = {}
ECR = {}

# Gates which should be translated to QubitUnitary
[operators.gates.matrix]

MultiControlledX = {}


[operators.observables]
# Observables supported by the device

PauliX = {}
PauliY = {}
PauliZ = {}
Hadamard = {}
Hermitian = {}
Identity = {}
Projector = {}
SparseHamiltonian = {}
Hamiltonian = {}
Sum = {}
SProd = {}
Prod = {}
Exp = {}

[measurement_processes.exactshots]

Expval = {}
Var = {}
Probs = {}
State = {}

[measurement_processes.finiteshots]

Expval = {}
Var = {}
Probs = {}
Sample = {}
Count = {}

[compilation]
# If the device is compatible with qjit
qjit_compatible = true
# If the device requires run time generation of the quantum circuit.
runtime_code_generation = false
# If the device supports adjoint
quantum_adjoint = true
# If the device supports mid circuit measurements natively
mid_circuit_measurement = true

# This field is currently unchecked but it is reserved for the purpose of
# determining if the device supports dynamic qubit allocation/deallocation.
dynamic_qubit_management = false
