schema = 1

[device]
name = "lightning.qubit"
precision = ['float32', 'float64']

[operations]
observables = [
        "PauliX",
        "PauliY",
        "PauliZ",
        "Hadamard",
        "Hermitian",
        "Identity",
        "Projector",
        "SparseHamiltonian",
        "Hamiltonian",
        "Sum",
        "SProd",
        "Prod",
        "Exp",
]

# These are gates that do not need decomposition.
# Also gates which are natively supported by the device.
[[operations.gates]]
native = [
        "Identity",
        "PauliX",
        "PauliY",
        "PauliZ",
        "Hadamard",
        "S",
        "T",
        "PhaseShift",
        "RX",
        "RY",
        "RZ",
        "Rot",
        "CNOT",
        "CY",
        "CZ",
        "SWAP",
        "CSWAP",
        "Toffoli",
        "IsingXX",
        "IsingXY",
        "IsingYY",
        "IsingZZ",
        "ControlledPhaseShift",
        "CRX",
        "CRY",
        "CRZ",
        "CRot",
        "SingleExcitation",
        "SingleExcitationPlus",
        "SingleExcitationMinus",
        "DoubleExcitation",
        "DoubleExcitationPlus",
        "DoubleExcitationMinus",
        "MultiRZ",
	# QubitUnitary is technically
	# "applyMatrix", but it doesn't
	# belong in matrix gates.
        "QubitUnitary",
]

# Gates listed in qml.device.ops
# which the authors of this file would like to be decomposed
# according to rules outlined in the decomposition strategy for each
# operation.
decomp = [
	# All adjoint operations in lightning_qubit
	# are applied via applyMatrix.
        "Adjoint(S)",
        "Adjoint(T)",
        "Adjoint(SX)",
        "Adjoint(ISWAP)",
        "Adjoint(SISWAP)",

	# The rest.
        "BasisState",
        "ECR",
        "QubitStateVector",
        "StatePrep",
        "ControlledQubitUnitary",
        "DiagonalQubitUnitary",
        "SX",
        "ISWAP",
        "PSWAP",
        "SISWAP",
        "SQISW",
        "CPhase",
        "QubitCarry",
        "QubitSum",
        "OrbitalRotation",
        "QFT",
]

# Gates listed in qml.device.ops
# which the authors of this file would like to be decomposed into QubitUnitary.
matrix = [
        "MultiControlledX",
]

[measurements]
exactshots = [
	"Expval",
	"Var",
	"Probs",
	"State",
]
finiteshots = [
	"Expval",
	"Var",
	"Probs",
	"Sample",
	"Counts",
]

[compilation]
qjit_compatible = true
runtime_code_generation = false
adjoint = true
quantum_control = false
mid_circuit_measurement = true
dynamic_qubit_management = false # true after merging `StateVectorLQubitDynamic` to the monorepo

[options]
mcmc = "_mcmc"
num_burnin = "_num_burnin"
kernel_name = "_kernel_name"
