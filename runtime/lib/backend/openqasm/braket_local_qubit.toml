schema = 1

[device]
name = "braket.aws.qubit"
precision = ['float64']

[operators]
observables = [
	"PauliX",
	"PauliY",
	"PauliZ",
	"Hadamard",
	"Hermitian",
	"Tensor",
]


# These are gates that are natively supported by the device.
[[operators.gates]]
native = [
	# These two are native but are not supported by the QIR runtime yet.
	# This is not a problem because we intersect the native gate set
	# with the gate set supported by the QIR runtime.
	# But it means that the compiler cannot use all native gates yet.
	# See https://github.com/PennyLaneAI/catalyst/issues/395
        "ISWAP",
        "PSWAP",

	"Hadamard",
        "PauliX",
        "PauliY",
        "PauliZ",
        "S",
        "T",
        "CNOT",
        "CZ",
        "SWAP",
        "PhaseShift",
        "RX",
        "RY",
        "RZ",
        "CSWAP",
	# Unlike "braket.aws.qubit"
	# The "braket.local.qubit" device does support QubitUnitary
	"QubitUnitary",

	"MS",
	"CY",
	"SX",
	"AAMS",
	"ECR",
	"GPi",
	"GPi2",
	"Adjoint(S)",
	"Adjoint(T)",
	"Adjoint(SX)",
	"CPhaseShift00",
	"CPhaseShift01",
	"CPhaseShift10",
	"Identity",
	"IsingXX",
	"IsingXY",
	"IsingYY",
	"IsingZZ",
	"Toffoli",
	"ControlledPhaseShift",
]

decomp = []

# QubitUnitary should never be here.
# Gates in "matrix" are decomposed to QubitUnitary.
# Having a QubitUnitary here would mean an infinite loop.
matrix = [
]

[measurements]
exactshots = [
	"Expval",
	"Var",
	"Probs",
	"State",
]
finiteshots = [
	"Expval",
	"Var",
	"Probs",
	"Sample",
	"Counts",
]

[compilation]
qjit_compatible = true
runtime_code_generation = true
adjoint = false
quantum_control = false
mid_circuit_measurement = false
dynamic_qubit_management = false 
