
NOTE: These definitions are subject to change/refinement under the
      "Better containers for quantum programs" epic.

### Assumptions

- A `FuncOp` carries the `qnode` unit attribute if and only if the function body contains and
  returns measurement processes from its scope. These operations are called "qnode functions".
  - A function calling out to another function that contains measurement processes does
    *not* count.
  - Measurement processes within non-isolated, nested operations, such as structured control
    flow branches, may be allowable for this criteria. (TBD)
- QNode functions live in a separate module nested under the root IR module which is referred
  to as a "quantum kernel".
  - The quantum kernel maintains the scope originally defined by Python user functions
    decorated with the `pennylane.qnode` decorator.
  - Transformation schedules generated from Python (e.g. when using pass decorators on
    `pennylane.QNode` objecs) are contained within the quantum kernel module, under a special
    anonymous module with the `transform.with_named_sequence` attribute.
  - Such transformations are thus always scoped to the entire quantum kernel.
  - NOTE: The kernel abstraction currently only exists until the `inline-nested-module` pass
    is run. This happens *after* quantum kernel transform schedules are applied.

Future consideration:
- Create a special `entry_point` unit attribute to identify a single function within a quantum
  kernel module as the start of a kernel "execution". For now, the `launch_kernel` operation
  is technically able to target any function within a quantum kernel, but in practice will
  correspond to the "entry point" of a PennyLane QNode. Multiple calls to the same kernel but
  different functions are currently not being generated by the frontend or any passes.


### Guidelines

- Passes targeting PennyLane QNodes must be written to run on `ModuleOp`s. (see assumptions)
  - This applies to xDSL as well as MLIR passes, since both are scheduled on the quantum kernel.
- Within a module, qnode functions need to be identified via the `qnode` attribute.
- Each QNode function should be processed once by the pass.
- A pass must exit early without error if it cannot find the objects or patterns it is
  designed to target. Execution should only be aborted where IR invariants or Catalyst program
  model expectations are clearly violated.
- Passes that wish to replace an existing qnode function with one or multiple qnode executions
  or with additional classical processing can do so by:
  - Creating new `FuncOp`s with the `qnode` attribute within the parent module of the targeted
    qnode function. These functions must have a different symbol name than the targeted qnode
    function.
  - The targeted qnode function is modified or replaced with a function calling the newly
    created qnode functions. This function is now a "classical" function and thus must not
    carry the `qnode` attribute anymore. The signature and symbol name of this classical
    function should remain the same, such that existing calls to it remain valid.
  - Arbitrary classical pre- and post-processing may be inserted into the new classical
    function. This is typically important in order to maintain the action of the original
    qnode function throughout transformation. For instance, a pass that turns `expval` MPs
    into `sample` MPs within a qnode function needs to insert classical processing that
    computes the average of the samples produced by the new qnode function.

Future consideration:
- We may want to consider allowing QNode passes to be scheduled on `FuncOp`s directly, for
  passes that only modify the internals of a QNode (think gate cancellation).
  - This would allow passes to run in parallel on different QNode functions within a
    quantum kernel module.
  - This would require adjustments to the transform interpreter pass, which currently only
    applies each pass once to the quantum kernel module.


### Notes

A few notes about how passes are applied in MLIR. Different ways to apply passes include:
- direct invocation from the commandline via `opt`, e.g. `quantum-opt --my-pass`
- textual pass pipeline invoked from the commandline, e.g.
  `quantum-opt --pass-pipeline='builtin.module(func.func(my-pass))'`
- programmatic invocation via a pass manager, e.g. `PassManager.addPass(MyPass())` and
  `PassManager.addNestedPass<func::FuncOp>(MyPass())`

- *Dialect conversion* and *rewrite pattern* passes are typically op-agnostic passes that invoke
  a pattern rewrite driver.
  - The root op for the pass must be isolated from above (e.g. `ModuleOp`, `FuncOp`).
  - The rewrite driver will traverse *all* nesting layers under the root op looking for
    operations that match the given patterns.
- *Op-agnostic* passes will be invoked on whatever they are scheduled on:
  - direct cmd: the (implicit) root module
  - textual pipeline: all ops of the given leaf type at the given nesting layer
- *Filtered op* passes will work on all ops of the declared type at *one* level of nesting
  for instance:
  - direct cmd: MLIR automatically applies the pass to the root module or to the op type
    in the first level under the root module. In particular, it will not descend into nested
    modules.
  - textual pipeline: The given pipeline leaf must match the filter op type. The pass is applied
    to all ops of that type at the specified nesting layer.
