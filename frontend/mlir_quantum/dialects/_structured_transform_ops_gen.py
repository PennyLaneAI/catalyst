
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _structured_transform_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ApplyEraseUnnecessaryInputsPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.erase_unnecessary_inputs"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ApplyFoldUnitExtentDimsViaReshapesPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.fold_unit_extent_dims_via_reshapes"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ApplyFoldUnitExtentDimsViaSlicesPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.fold_unit_extent_dims_via_slices"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ApplyTilingCanonicalizationPatternsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.apply_patterns.linalg.tiling_canonicalization"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BufferizeToAllocationOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.bufferize_to_allocation"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, memory_space=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_space is not None: attributes["memory_space"] = (memory_space if (
        issubclass(type(memory_space), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(memory_space, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def memory_space(self):
    if "memory_space" not in self.operation.attributes:
      return None
    return _ods_ir.Attribute(self.operation.attributes["memory_space"])

  @memory_space.setter
  def memory_space(self, value):
    if value is not None:
      self.operation.attributes["memory_space"] = value
    elif "memory_space" in self.operation.attributes:
      del self.operation.attributes["memory_space"]

  @memory_space.deleter
  def memory_space(self):
    del self.operation.attributes["memory_space"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvertConv2DToImg2ColOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.convert_conv2d_to_img2col"

  _ODS_REGIONS = (0, True)

  def __init__(self, img2col_tensor, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(img2col_tensor)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def img2col_tensor(self):
    return self.operation.results[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DecomposeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.decompose"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FuseIntoContainingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse_into_containing_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, fused_op, new_containing_op, producer_op, containing_op, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(producer_op))
    operands.append(_get_op_result_or_value(containing_op))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(fused_op)
    results.append(new_containing_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def producer_op(self):
    return self.operation.operands[0]

  @builtins.property
  def containing_op(self):
    return self.operation.operands[1]

  @builtins.property
  def fused_op(self):
    return self.operation.results[0]

  @builtins.property
  def new_containing_op(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FuseOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, loops, target, *, tile_sizes=None, tile_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if tile_sizes is not None: attributes["tile_sizes"] = (tile_sizes if (
        issubclass(type(tile_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile_sizes, context=_ods_context))
    if tile_interchange is not None: attributes["tile_interchange"] = (tile_interchange if (
        issubclass(type(tile_interchange), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile_interchange, context=_ods_context))
    results.append(transformed)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GeneralizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.generalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HoistPadBuildPackingLoopNestOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_pad.build_packing_loop_nest"

  _ODS_REGIONS = (0, True)

  def __init__(self, packing_loop, target, loop, *, transpose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.append(_get_op_result_or_value(loop))
    _ods_context = _ods_get_default_loc_context(loc)
    if transpose is not None: attributes["transpose"] = (transpose if (
        issubclass(type(transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(transpose, context=_ods_context))
    results.append(packing_loop)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def loop(self):
    return self.operation.operands[1]

  @builtins.property
  def packing_loop(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HoistPadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, num_loops, *, transpose=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_loops"] = (num_loops if (
    issubclass(type(num_loops), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_loops, context=_ods_context))
    if transpose is not None: attributes["transpose"] = (transpose if (
        issubclass(type(transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(transpose, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def num_loops(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["num_loops"])

  @num_loops.setter
  def num_loops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_loops"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HoistRedundantTensorSubsetsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_redundant_tensor_subsets"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HoistRedundantVectorTransfersOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.hoist_redundant_vector_transfers"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InsertSliceToCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.insert_slice_to_copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InterchangeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.interchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, iterator_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if iterator_interchange is not None: attributes["iterator_interchange"] = (iterator_interchange if (
        issubclass(type(iterator_interchange), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(iterator_interchange, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LowerPackOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.lower_pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, pad_op, expand_shape_op, transpose_op, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(pad_op)
    results.append(expand_shape_op)
    results.append(transpose_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def pad_op(self):
    return self.operation.results[0]

  @builtins.property
  def expand_shape_op(self):
    return self.operation.results[1]

  @builtins.property
  def transpose_op(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LowerUnPackOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.lower_unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, empty_op, transpose_op, collapse_shape_op, extract_slice_op, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(empty_op)
    results.append(transpose_op)
    results.append(collapse_shape_op)
    results.append(extract_slice_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def empty_op(self):
    return self.operation.results[0]

  @builtins.property
  def transpose_op(self):
    return self.operation.results[1]

  @builtins.property
  def collapse_shape_op(self):
    return self.operation.results[2]

  @builtins.property
  def extract_slice_op(self):
    return self.operation.results[3]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskedVectorizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.masked_vectorize"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, vector_sizes, *, vectorize_nd_extract=None, static_vector_sizes=None, last_vector_size_scalable=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(vector_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(vectorize_nd_extract): attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if static_vector_sizes is not None: attributes["static_vector_sizes"] = (static_vector_sizes if (
        issubclass(type(static_vector_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_vector_sizes, context=_ods_context))
    if last_vector_size_scalable is not None: attributes["last_vector_size_scalable"] = (last_vector_size_scalable if (
        issubclass(type(last_vector_size_scalable), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(last_vector_size_scalable, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def vector_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def vectorize_nd_extract(self):
    return "vectorize_nd_extract" in self.operation.attributes

  @vectorize_nd_extract.setter
  def vectorize_nd_extract(self, value):
    if bool(value):
      self.operation.attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get()
    elif "vectorize_nd_extract" in self.operation.attributes:
      del self.operation.attributes["vectorize_nd_extract"]

  @vectorize_nd_extract.deleter
  def vectorize_nd_extract(self):
    del self.operation.attributes["vectorize_nd_extract"]

  @builtins.property
  def last_vector_size_scalable(self):
    if "last_vector_size_scalable" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["last_vector_size_scalable"])

  @last_vector_size_scalable.setter
  def last_vector_size_scalable(self, value):
    if value is not None:
      self.operation.attributes["last_vector_size_scalable"] = value
    elif "last_vector_size_scalable" in self.operation.attributes:
      del self.operation.attributes["last_vector_size_scalable"]

  @last_vector_size_scalable.deleter
  def last_vector_size_scalable(self):
    del self.operation.attributes["last_vector_size_scalable"]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatchOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.match"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, target, *, ops=None, interface=None, op_attrs=None, filter_result_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if ops is not None: attributes["ops"] = (ops if (
        issubclass(type(ops), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(ops, context=_ods_context))
    if interface is not None: attributes["interface"] = (interface if (
        issubclass(type(interface), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('MatchInterfaceEnum')) else
          _ods_ir.AttrBuilder.get('MatchInterfaceEnum')(interface, context=_ods_context))
    if op_attrs is not None: attributes["op_attrs"] = (op_attrs if (
        issubclass(type(op_attrs), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(op_attrs, context=_ods_context))
    if filter_result_type is not None: attributes["filter_result_type"] = (filter_result_type if (
        issubclass(type(filter_result_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypeAttr')) else
          _ods_ir.AttrBuilder.get('TypeAttr')(filter_result_type, context=_ods_context))
    results.append(results_)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MultiTileSizesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.multitile_sizes"

  _ODS_REGIONS = (0, True)

  def __init__(self, low_size, high_size, split_point, target, dimension, target_size, *, divisor=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    issubclass(type(dimension), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    attributes["target_size"] = (target_size if (
    issubclass(type(target_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(target_size, context=_ods_context))
    if divisor is not None: attributes["divisor"] = (divisor if (
        issubclass(type(divisor), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(divisor, context=_ods_context))
    results.append(low_size)
    results.append(high_size)
    results.append(split_point)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dimension"])

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def target_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["target_size"])

  @target_size.setter
  def target_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_size"] = value

  @builtins.property
  def divisor(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["divisor"])

  @divisor.setter
  def divisor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["divisor"] = value

  @builtins.property
  def low_size(self):
    return self.operation.results[0]

  @builtins.property
  def high_size(self):
    return self.operation.results[1]

  @builtins.property
  def split_point(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PackGreedilyOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pack_greedily"

  _ODS_REGIONS = (0, True)

  def __init__(self, packed_op, target, matmul_packed_sizes, *, static_matmul_packed_sizes=None, matmul_padded_sizes_next_multiple_of=None, matmul_inner_dims_order=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(matmul_packed_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_matmul_packed_sizes is not None: attributes["static_matmul_packed_sizes"] = (static_matmul_packed_sizes if (
        issubclass(type(static_matmul_packed_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_matmul_packed_sizes, context=_ods_context))
    if matmul_padded_sizes_next_multiple_of is not None: attributes["matmul_padded_sizes_next_multiple_of"] = (matmul_padded_sizes_next_multiple_of if (
        issubclass(type(matmul_padded_sizes_next_multiple_of), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(matmul_padded_sizes_next_multiple_of, context=_ods_context))
    if matmul_inner_dims_order is not None: attributes["matmul_inner_dims_order"] = (matmul_inner_dims_order if (
        issubclass(type(matmul_inner_dims_order), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(matmul_inner_dims_order, context=_ods_context))
    results.append(packed_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def matmul_packed_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def packed_op(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PackOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, packed_op, target, packed_sizes, *, static_packed_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(packed_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_packed_sizes is not None: attributes["static_packed_sizes"] = (static_packed_sizes if (
        issubclass(type(static_packed_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_packed_sizes, context=_ods_context))
    results.append(packed_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def packed_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def packed_op(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PackTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pack_transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, packed_op, pack_op, un_pack_op, target_pack_or_un_pack_op, target_linalg_op, *, outer_perm=None, inner_perm=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target_pack_or_un_pack_op))
    operands.append(_get_op_result_or_value(target_linalg_op))
    _ods_context = _ods_get_default_loc_context(loc)
    if outer_perm is not None: attributes["outer_perm"] = (outer_perm if (
        issubclass(type(outer_perm), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(outer_perm, context=_ods_context))
    if inner_perm is not None: attributes["inner_perm"] = (inner_perm if (
        issubclass(type(inner_perm), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(inner_perm, context=_ods_context))
    results.append(packed_op)
    results.append(pack_op)
    results.append(un_pack_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target_pack_or_un_pack_op(self):
    return self.operation.operands[0]

  @builtins.property
  def target_linalg_op(self):
    return self.operation.operands[1]

  @builtins.property
  def packed_op(self):
    return self.operation.results[0]

  @builtins.property
  def pack_op(self):
    return self.operation.results[1]

  @builtins.property
  def un_pack_op(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, padding_values=None, padding_dimensions=None, pad_to_multiple_of=None, pack_paddings=None, transpose_paddings=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if padding_values is not None: attributes["padding_values"] = (padding_values if (
        issubclass(type(padding_values), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(padding_values, context=_ods_context))
    if padding_dimensions is not None: attributes["padding_dimensions"] = (padding_dimensions if (
        issubclass(type(padding_dimensions), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(padding_dimensions, context=_ods_context))
    if pad_to_multiple_of is not None: attributes["pad_to_multiple_of"] = (pad_to_multiple_of if (
        issubclass(type(pad_to_multiple_of), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pad_to_multiple_of, context=_ods_context))
    if pack_paddings is not None: attributes["pack_paddings"] = (pack_paddings if (
        issubclass(type(pack_paddings), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(pack_paddings, context=_ods_context))
    if transpose_paddings is not None: attributes["transpose_paddings"] = (transpose_paddings if (
        issubclass(type(transpose_paddings), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_450')) else
          _ods_ir.AttrBuilder.get('anonymous_450')(transpose_paddings, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PromoteOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.promote"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, operands_to_promote=None, use_full_tile_buffers=None, use_full_tiles_by_default=None, use_alloca=None, mapping=None, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if operands_to_promote is not None: attributes["operands_to_promote"] = (operands_to_promote if (
        issubclass(type(operands_to_promote), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(operands_to_promote, context=_ods_context))
    if use_full_tile_buffers is not None: attributes["use_full_tile_buffers"] = (use_full_tile_buffers if (
        issubclass(type(use_full_tile_buffers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(use_full_tile_buffers, context=_ods_context))
    if bool(use_full_tiles_by_default): attributes["use_full_tiles_by_default"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloca): attributes["use_alloca"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if mapping is not None: attributes["mapping"] = (mapping if (
        issubclass(type(mapping), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceMappingArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceMappingArrayAttr')(mapping, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        issubclass(type(alignment), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(alignment, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def use_full_tiles_by_default(self):
    return "use_full_tiles_by_default" in self.operation.attributes

  @use_full_tiles_by_default.setter
  def use_full_tiles_by_default(self, value):
    if bool(value):
      self.operation.attributes["use_full_tiles_by_default"] = _ods_ir.UnitAttr.get()
    elif "use_full_tiles_by_default" in self.operation.attributes:
      del self.operation.attributes["use_full_tiles_by_default"]

  @use_full_tiles_by_default.deleter
  def use_full_tiles_by_default(self):
    del self.operation.attributes["use_full_tiles_by_default"]

  @builtins.property
  def use_alloca(self):
    return "use_alloca" in self.operation.attributes

  @use_alloca.setter
  def use_alloca(self, value):
    if bool(value):
      self.operation.attributes["use_alloca"] = _ods_ir.UnitAttr.get()
    elif "use_alloca" in self.operation.attributes:
      del self.operation.attributes["use_alloca"]

  @use_alloca.deleter
  def use_alloca(self):
    del self.operation.attributes["use_alloca"]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return _ods_ir.IntegerAttr(self.operation.attributes["alignment"])

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReplaceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.replace"

  _ODS_REGIONS = (1, True)

  def __init__(self, replacement, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(replacement)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def replacement(self):
    return self.operation.results[0]

  @builtins.property
  def bodyRegion(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RewriteInDestinationPassingStyleOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.rewrite_in_destination_passing_style"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScalarizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.scalarize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, first, second, target, dimension, static_split_point, *, dynamic_split_point=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if dynamic_split_point is not None: operands.append(_get_op_result_or_value(dynamic_split_point))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    issubclass(type(dimension), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    attributes["static_split_point"] = (static_split_point if (
    issubclass(type(static_split_point), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(static_split_point, context=_ods_context))
    results.append(first)
    results.append(second)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_split_point(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dimension"])

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def static_split_point(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["static_split_point"])

  @static_split_point.setter
  def static_split_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_split_point"] = value

  @builtins.property
  def first(self):
    return self.operation.results[0]

  @builtins.property
  def second(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitReductionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split_reduction"

  _ODS_REGIONS = (0, True)

  def __init__(self, init_or_alloc_op, fill_op, split_linalg_op, combining_linalg_op, target, *, split_factor=None, insert_split_dimension=None, inner_parallel=None, use_scaling_algorithm=None, use_alloc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if split_factor is not None: attributes["split_factor"] = (split_factor if (
        issubclass(type(split_factor), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(split_factor, context=_ods_context))
    if insert_split_dimension is not None: attributes["insert_split_dimension"] = (insert_split_dimension if (
        issubclass(type(insert_split_dimension), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(insert_split_dimension, context=_ods_context))
    if bool(inner_parallel): attributes["inner_parallel"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_scaling_algorithm): attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloc): attributes["use_alloc"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(init_or_alloc_op)
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def split_factor(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["split_factor"])

  @split_factor.setter
  def split_factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["split_factor"] = value

  @builtins.property
  def insert_split_dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["insert_split_dimension"])

  @insert_split_dimension.setter
  def insert_split_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["insert_split_dimension"] = value

  @builtins.property
  def inner_parallel(self):
    return "inner_parallel" in self.operation.attributes

  @inner_parallel.setter
  def inner_parallel(self, value):
    if bool(value):
      self.operation.attributes["inner_parallel"] = _ods_ir.UnitAttr.get()
    elif "inner_parallel" in self.operation.attributes:
      del self.operation.attributes["inner_parallel"]

  @inner_parallel.deleter
  def inner_parallel(self):
    del self.operation.attributes["inner_parallel"]

  @builtins.property
  def use_scaling_algorithm(self):
    return "use_scaling_algorithm" in self.operation.attributes

  @use_scaling_algorithm.setter
  def use_scaling_algorithm(self, value):
    if bool(value):
      self.operation.attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get()
    elif "use_scaling_algorithm" in self.operation.attributes:
      del self.operation.attributes["use_scaling_algorithm"]

  @use_scaling_algorithm.deleter
  def use_scaling_algorithm(self):
    del self.operation.attributes["use_scaling_algorithm"]

  @builtins.property
  def use_alloc(self):
    return "use_alloc" in self.operation.attributes

  @use_alloc.setter
  def use_alloc(self, value):
    if bool(value):
      self.operation.attributes["use_alloc"] = _ods_ir.UnitAttr.get()
    elif "use_alloc" in self.operation.attributes:
      del self.operation.attributes["use_alloc"]

  @use_alloc.deleter
  def use_alloc(self):
    del self.operation.attributes["use_alloc"]

  @builtins.property
  def init_or_alloc_op(self):
    return self.operation.results[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[1]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[2]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[3]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_linalg_op, loops, target, dynamic_sizes, *, static_sizes=None, interchange=None, last_tile_size_scalable=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(dynamic_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_sizes is not None: attributes["static_sizes"] = (static_sizes if (
        issubclass(type(static_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_sizes, context=_ods_context))
    if interchange is not None: attributes["interchange"] = (interchange if (
        issubclass(type(interchange), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(interchange, context=_ods_context))
    if last_tile_size_scalable is not None: attributes["last_tile_size_scalable"] = (last_tile_size_scalable if (
        issubclass(type(last_tile_size_scalable), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(last_tile_size_scalable, context=_ods_context))
    results.append(tiled_linalg_op)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def last_tile_size_scalable(self):
    if "last_tile_size_scalable" not in self.operation.attributes:
      return None
    return _ods_ir.BoolAttr(self.operation.attributes["last_tile_size_scalable"])

  @last_tile_size_scalable.setter
  def last_tile_size_scalable(self, value):
    if value is not None:
      self.operation.attributes["last_tile_size_scalable"] = value
    elif "last_tile_size_scalable" in self.operation.attributes:
      del self.operation.attributes["last_tile_size_scalable"]

  @last_tile_size_scalable.deleter
  def last_tile_size_scalable(self):
    del self.operation.attributes["last_tile_size_scalable"]

  @builtins.property
  def tiled_linalg_op(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileReductionUsingForallOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_reduction_using_forall"

  _ODS_REGIONS = (0, True)

  def __init__(self, forall_op, fill_op, split_linalg_op, combining_linalg_op, target, *, num_threads=None, tile_sizes=None, mapping=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if num_threads is not None: attributes["num_threads"] = (num_threads if (
        issubclass(type(num_threads), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(num_threads, context=_ods_context))
    if tile_sizes is not None: attributes["tile_sizes"] = (tile_sizes if (
        issubclass(type(tile_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(tile_sizes, context=_ods_context))
    if mapping is not None: attributes["mapping"] = (mapping if (
        issubclass(type(mapping), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceMappingArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceMappingArrayAttr')(mapping, context=_ods_context))
    results.append(forall_op)
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def forall_op(self):
    return self.operation.results[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[1]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[2]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[3]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileReductionUsingScfOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_reduction_using_scf"

  _ODS_REGIONS = (0, True)

  def __init__(self, for_op, fill_op, split_linalg_op, combining_linalg_op, target, *, tile_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if tile_sizes is not None: attributes["tile_sizes"] = (tile_sizes if (
        issubclass(type(tile_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(tile_sizes, context=_ods_context))
    results.append(for_op)
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def for_op(self):
    return self.operation.results[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[1]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[2]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[3]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileToForallOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_to_forall_op"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, forall_op, tiled_op, target, num_threads, tile_sizes, *, packed_num_threads=None, packed_tile_sizes=None, static_num_threads=None, static_tile_sizes=None, mapping=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.append(_get_op_results_or_values(num_threads))
    operands.append(_get_op_results_or_values(tile_sizes))
    operands.append(_get_op_result_or_value(packed_num_threads) if packed_num_threads is not None else None)
    operands.append(_get_op_result_or_value(packed_tile_sizes) if packed_tile_sizes is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if static_num_threads is not None: attributes["static_num_threads"] = (static_num_threads if (
        issubclass(type(static_num_threads), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_num_threads, context=_ods_context))
    if static_tile_sizes is not None: attributes["static_tile_sizes"] = (static_tile_sizes if (
        issubclass(type(static_tile_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_tile_sizes, context=_ods_context))
    if mapping is not None: attributes["mapping"] = (mapping if (
        issubclass(type(mapping), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceMappingArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceMappingArrayAttr')(mapping, context=_ods_context))
    results.append(forall_op)
    results.append(tiled_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 0)
    return operand_range[0]

  @builtins.property
  def num_threads(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 1)
    return operand_range

  @builtins.property
  def tile_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 2)
    return operand_range

  @builtins.property
  def packed_num_threads(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def packed_tile_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def forall_op(self):
    return self.operation.results[0]

  @builtins.property
  def tiled_op(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileToScfForOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_to_scf_for"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_linalg_op, loops, target, dynamic_sizes, *, static_sizes=None, interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(dynamic_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if static_sizes is not None: attributes["static_sizes"] = (static_sizes if (
        issubclass(type(static_sizes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_sizes, context=_ods_context))
    if interchange is not None: attributes["interchange"] = (interchange if (
        issubclass(type(interchange), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(interchange, context=_ods_context))
    results.append(tiled_linalg_op)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def tiled_linalg_op(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VectorizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.vectorize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, vectorize_padding=None, vectorize_nd_extract=None, disable_multi_reduction_to_contract_patterns=None, disable_transfer_permutation_map_lowering_patterns=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(vectorize_padding): attributes["vectorize_padding"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(vectorize_nd_extract): attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(disable_multi_reduction_to_contract_patterns): attributes["disable_multi_reduction_to_contract_patterns"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(disable_transfer_permutation_map_lowering_patterns): attributes["disable_transfer_permutation_map_lowering_patterns"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def vectorize_padding(self):
    return "vectorize_padding" in self.operation.attributes

  @vectorize_padding.setter
  def vectorize_padding(self, value):
    if bool(value):
      self.operation.attributes["vectorize_padding"] = _ods_ir.UnitAttr.get()
    elif "vectorize_padding" in self.operation.attributes:
      del self.operation.attributes["vectorize_padding"]

  @vectorize_padding.deleter
  def vectorize_padding(self):
    del self.operation.attributes["vectorize_padding"]

  @builtins.property
  def vectorize_nd_extract(self):
    return "vectorize_nd_extract" in self.operation.attributes

  @vectorize_nd_extract.setter
  def vectorize_nd_extract(self, value):
    if bool(value):
      self.operation.attributes["vectorize_nd_extract"] = _ods_ir.UnitAttr.get()
    elif "vectorize_nd_extract" in self.operation.attributes:
      del self.operation.attributes["vectorize_nd_extract"]

  @vectorize_nd_extract.deleter
  def vectorize_nd_extract(self):
    del self.operation.attributes["vectorize_nd_extract"]

  @builtins.property
  def disable_multi_reduction_to_contract_patterns(self):
    return "disable_multi_reduction_to_contract_patterns" in self.operation.attributes

  @disable_multi_reduction_to_contract_patterns.setter
  def disable_multi_reduction_to_contract_patterns(self, value):
    if bool(value):
      self.operation.attributes["disable_multi_reduction_to_contract_patterns"] = _ods_ir.UnitAttr.get()
    elif "disable_multi_reduction_to_contract_patterns" in self.operation.attributes:
      del self.operation.attributes["disable_multi_reduction_to_contract_patterns"]

  @disable_multi_reduction_to_contract_patterns.deleter
  def disable_multi_reduction_to_contract_patterns(self):
    del self.operation.attributes["disable_multi_reduction_to_contract_patterns"]

  @builtins.property
  def disable_transfer_permutation_map_lowering_patterns(self):
    return "disable_transfer_permutation_map_lowering_patterns" in self.operation.attributes

  @disable_transfer_permutation_map_lowering_patterns.setter
  def disable_transfer_permutation_map_lowering_patterns(self, value):
    if bool(value):
      self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"] = _ods_ir.UnitAttr.get()
    elif "disable_transfer_permutation_map_lowering_patterns" in self.operation.attributes:
      del self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"]

  @disable_transfer_permutation_map_lowering_patterns.deleter
  def disable_transfer_permutation_map_lowering_patterns(self):
    del self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]
