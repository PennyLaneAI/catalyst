<link rel="stylesheet" href="https://mlir.llvm.org/css/theme.min.css">
<link rel="stylesheet" href="https://mlir.llvm.org/css/chroma.min.css">
<link rel="stylesheet" href="../../../_static/mlir-catalyst-ops.css">

<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `qec.fabricate` (::catalyst::qec::FabricateOp)

_Fabricate axillary qubits from qubit factories._

Syntax:

```
operation ::= `qec.fabricate` $init_state attr-dict `:` type($out_qubits)
```

The FabricateOp represents a operation that produces/fetches auxiliary qubits from a qubit factory.

FabricateOp is used to prepare states not normally available in an error correction scheme,
such as magic states |m⟩ (magic) and |m̅⟩ (magic_conj), or |Y⟩ (plus_i), and |-Y⟩ (minus_i)
in some instances. For states constructible within the scheme, use `PrepareStateOp` instead.
Contrary to `PrepareStateOp`, this operation does not operate on existing qubits.

Example:
```mlir
%0 = qec.fabricate magic: !quantum.bit
%1 = qec.fabricate magic_conj: !quantum.bit
%2 = qec.fabricate plus_i: !quantum.bit
%3 = qec.fabricate minus_i: !quantum.bit
```

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>init_state</code></td><td>::catalyst::qec::LogicalInitKindAttr</td><td>The initial state of a logical qubit such as |0⟩, |1⟩, |+⟩, |−⟩, |Y⟩, |-Y⟩, |m⟩, or |m̅⟩.</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `qec.layer` (::catalyst::qec::LayerOp)

_A layer operation_

The `qec.layer` operation represents a group of PPR/PPM operations that are
either mutually commutative within the group or act on different qubits.

`qec.layer` operates on carried variables and returns the final values after termination.

The body region must contain exactly one block that terminates with `qec.yield`.

Example:
```mlir
func.func @layer(%arg0 : !quantum.bit, %arg1 : i1) -> i1 {
    %m, %0 = qec.layer(%q0 = %arg0, %c = %arg1) : !quantum.bit, i1 {
        %res, %q_1 = qec.ppm ["Z"](4) %q0 cond(%c): !quantum.bit
        qec.yield %res, %q_1 : i1, !quantum.bit
    }
    func.return %m : i1
}
```

Traits: `SingleBlockImplicitTerminator<YieldOp>`, `SingleBlock`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `initArgs` | variadic of any type |

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type |


### `qec.ppm` (::catalyst::qec::PPMeasurementOp)

_Pauli Product Measurement on qubits._

Syntax:

```
operation ::= `qec.ppm` $pauli_product (`(` $rotation_sign^ `)`)? $in_qubits (`cond` `(` $condition^ `)`)? attr-dict `:` type($out_qubits)
```

The PPMeasurementOp represents a Pauli product measurement operation.
It measures a set of qubits in the basis specified by a Pauli product.

The operation is characterized by:
1. A Pauli product (e.g., ["X", "I", "Z"]) specifying the measurement basis
2. A list of input qubits to measure

The operation returns:
1. A measurement result (1-bit classical value)
2. The post-measurement state of the qubits

Example:
```mlir
%result, %q0:3 = qec.ppm ["X", "I", "Z"] %q0, %q1, %q2 : !quantum.bit, !quantum.bit, !quantum.bit
```
This measures the three qubits in the X⊗I⊗Z basis.

Traits: `AttrSizedOperandSegments`

Interfaces: `QECOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>pauli_product</code></td><td>::mlir::ArrayAttr</td><td>A product of Pauli operators, aka a Pauli word.</td></tr>
<tr><td><code>rotation_sign</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `in_qubits` | variadic of A value-semantic qubit (state). |
| `condition` | 1-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `mres` | 1-bit signless integer |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `qec.ppr` (::catalyst::qec::PPRotationOp)

_Pauli Product Rotation on qubits._

Syntax:

```
operation ::= `qec.ppr` $pauli_product `(` $rotation_kind `)` $in_qubits attr-dict (`cond` `(` $condition^ `)`)? `:` type($out_qubits)
```

The PPRotationOp represents a Pauli product rotation operation on a set of qubits.
It applies a rotation of the form exp(iθP) where:
- P is a Pauli product (specified by pauli_product)
- θ is the rotation angle (specified by rotation_kind in fractions of π)

The operation is characterized by:
1. A Pauli product (e.g., ["X", "I", "Z"]) specifying which Pauli operators to apply
2. A rotation kind (in fractions of π) specifying the angle
3. A list of input qubits to apply the rotation to

The operation returns the same number of qubits as input.

Example:
```mlir
%result = qec.ppr ["X", "I", "Z"](4) %q0, %q1, %q2 : !quantum.bit, !quantum.bit, !quantum.bit
```
This applies exp(iπ/4 * X⊗I⊗Z) to the three qubits.

Traits: `AttrSizedOperandSegments`

Interfaces: `QECOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>pauli_product</code></td><td>::mlir::ArrayAttr</td><td>A product of Pauli operators, aka a Pauli word.</td></tr>
<tr><td><code>rotation_kind</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `in_qubits` | variadic of A value-semantic qubit (state). |
| `condition` | 1-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `qec.prepare` (::catalyst::qec::PrepareStateOp)

_Initialize existing qubits into a given state._

Syntax:

```
operation ::= `qec.prepare` $init_state $in_qubits attr-dict `:` type($out_qubits)
```

Prepares non-magic states of logical qubits in a specific initial quantum state, 
such as |0⟩, |1⟩, |+⟩, |-⟩, |Y⟩, |-Y⟩. 
The input state of qubits can be any state, not necessarily |0⟩.

By default, when allocating a qubit using `quantum.alloc_qb` or `quantum.alloc`, 
it is prepared in the |0⟩ state.

Based on QEC scheme, |Y⟩ (plus_i) and |-Y⟩ (minus_i) can be prepared as transversal 
operations. Otherwise, if those states are fabricated, `FabricateOp` should be used.

Magic state such as |m⟩ (magic) and |m̅⟩ (magic_conj) cannot be prepared 
by this operation, use `FabricateOp` instead.

Example:
```mlir
%0 = qec.prepare zero %q0 : !quantum.bit
%1 = qec.prepare one %q1 : !quantum.bit
%2 = qec.prepare plus %q2 : !quantum.bit
%3 = qec.prepare minus %q3 : !quantum.bit
%4 = qec.prepare plus_i %q4 : !quantum.bit
```
These prepares the logical qubit in the |0⟩ state and the |m⟩ state respectively.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>init_state</code></td><td>::catalyst::qec::LogicalInitKindAttr</td><td>The initial state of a logical qubit such as |0⟩, |1⟩, |+⟩, |−⟩, |Y⟩, |-Y⟩, |m⟩, or |m̅⟩.</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `in_qubits` | variadic of A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `qec.select.ppm` (::catalyst::qec::SelectPPMeasurementOp)

_Multiplexed Pauli product measurement._

Syntax:

```
operation ::= `qec.select.ppm` `(` $select_switch `,` $pauli_product_0 `,` $pauli_product_1 `)` $in_qubits attr-dict `:` type($out_qubits)
```

Based on the boolean `select_switch` (type `i1`), this op selects between two Pauli product strings:  
- If `select_switch` is 1, applies and measures using `pauli_product_0`.  
- If `select_switch` is 0, uses `pauli_product_1`.  

The operation returns:
- `mres`: the result of the Pauli product measurement (`i1`)
- `out_qubits`: post-measurement qubits

Example:
```mlir
%m3, %3 = qec.select.ppm (%m1, ["X"], ["Z"]) %1#1 : !quantum.bit
```
If %m1 == 1, applies "X" to %1#1; else applies "Z". Then measures.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>pauli_product_0</code></td><td>::mlir::ArrayAttr</td><td>A product of Pauli operators, aka a Pauli word.</td></tr>
<tr><td><code>pauli_product_1</code></td><td>::mlir::ArrayAttr</td><td>A product of Pauli operators, aka a Pauli word.</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `select_switch` | 1-bit signless integer |
| `in_qubits` | variadic of A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `mres` | 1-bit signless integer |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `qec.yield` (::catalyst::qec::YieldOp)

_Return results from a layer region_

Syntax:

```
operation ::= `qec.yield` attr-dict ($results^ `:` type($results))?
```

Traits: `AlwaysSpeculatableImplTrait`, `HasParent<LayerOp>`, `ReturnLike`, `Terminator`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `results` | variadic of any type |

