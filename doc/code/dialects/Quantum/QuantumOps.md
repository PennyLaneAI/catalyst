<link rel="stylesheet" href="https://mlir.llvm.org/css/theme.min.css">
<link rel="stylesheet" href="https://mlir.llvm.org/css/chroma.min.css">
<link rel="stylesheet" href="../../../_static/mlir-catalyst-ops.css">

<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `quantum.adjoint` (::catalyst::quantum::AdjointOp)

_Calculate the adjoint of the enclosed operations_

Syntax:

```
operation ::= `quantum.adjoint` `(` $qreg `)` attr-dict `:` type(operands) $region
```

Traits: `SingleBlockImplicitTerminator<YieldOp>`, `SingleBlock`

Interfaces: `NoMemoryEffect (MemoryEffectOpInterface)`, `QuantumRegion`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `qreg` | An array of value-semantic qubits (i.e. quantum register). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qreg` | An array of value-semantic qubits (i.e. quantum register). |


### `quantum.alloc` (::catalyst::quantum::AllocOp)

_Allocate n qubits into a quantum register._

Syntax:

```
operation ::= `quantum.alloc` `(` ($nqubits^):($nqubits_attr)? `)` attr-dict `:` type(results)
```

Interfaces: `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>nqubits_attr</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is non-negative</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `nqubits` | 64-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `qreg` | An array of value-semantic qubits (i.e. quantum register). |


### `quantum.alloc_qb` (::catalyst::quantum::AllocQubitOp)

_Allocate a single qubit._

Syntax:

```
operation ::= `quantum.alloc_qb` attr-dict `:` type(results)
```

#### Results:

| Result | Description |
| :----: | ----------- |
| `qubit` | A value-semantic qubit (state). |


### `quantum.compbasis` (::catalyst::quantum::ComputationalBasisOp)

_Define a pseudo-obeservable of the computational basis for use in measurements_

Syntax:

```
operation ::= `quantum.compbasis` (`qubits` $qubits^)? (`qreg` $qreg^)? attr-dict `:` type(results)
```

The `quantum.compbasis` operation defines a quantum observable to be used by other
operations such as measurement processes. The specific observable defined here is a
"pseudo" observable to represent measurements in the computational basis.
The only arguments are either the list of qubits to measure, or the quantum register
to measure. When the argument is a register, the measurement occurs on all qubits in
the register.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %r: !quantum.reg)
{
    %obs_q = quantum.compbasis qubits %q0, %q1 : !quantum.obs
    %obs_r = quantum.compbasis qreg %r : !quantum.obs
    func.return
}
```

Traits: `AlwaysSpeculatableImplTrait`, `AttrSizedOperandSegments`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `qubits` | variadic of A value-semantic qubit (state). |
| `qreg` | An array of value-semantic qubits (i.e. quantum register). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `obs` | A quantum observable for use in measurements. |


### `quantum.counts` (::catalyst::quantum::CountsOp)

_Compute sample counts for the given observable for the current state_

Syntax:

```
operation ::= `quantum.counts` $obs ( `shape` $dynamic_shape^ )?
              ( `in` `(` $in_eigvals^ `:` type($in_eigvals) `,` $in_counts `:` type($in_counts) `)` )?
              attr-dict ( `:` type($eigvals)^ `,` type($counts) )?
```

The `quantum.counts` operation represents the measurement process of sampling eigenvalues
from an observable on the current quantum state and counting the frequency of each
eigenvalue.
The only SSA argument is an observable that must be defined by an operation in the local scope.
from an observable on the current quantum state.
The number of samples to draw is determined by the device shots argument in the device initialization operation in the local scope.

Note that the "counts dictionary" is returned as two separate arrays of the same length, one
array for the eigenvalues, and one for count of each eigenvalue. When operating in the
computational basis, the "eigenvalues" are the possible bitstrings one could measure on the
given qubits, encoded as (floating-point) integers.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
{
    quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
    %obs = quantum.compbasis %q0, %q1 : !quantum.obs
    %counts = quantum.counts %obs : tensor<4xf64>, tensor<4xi64>

    %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
    %counts2 = quantum.counts %obs2 : tensor<2xf64>, tensor<2xi64>

    func.return
}
```

Traits: `AttrSizedOperandSegments`, `SameVariadicResultSize`

Interfaces: `MeasurementProcess`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `obs` | A quantum observable for use in measurements. |
| `dynamic_shape` | 64-bit signless integer |
| `in_eigvals` | 1D memref of 64-bit float values |
| `in_counts` | 1D memref of 64-bit signless integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `eigvals` | 1D tensor of 64-bit float values |
| `counts` | 1D tensor of 64-bit signless integer values |


### `quantum.custom` (::catalyst::quantum::CustomOp)

_A generic quantum gate on n qubits with m floating point parameters._

Syntax:

```
operation ::= `quantum.custom` $gate_name `(` $params `)` $in_qubits (`adj` $adjoint^)? attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
```

Traits: `AttrSizedOperandSegments`, `AttrSizedResultSegments`, `Unitary`

Interfaces: `DifferentiableGate`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ParametrizedGate`, `QuantumGate`, `QuantumOperation`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>gate_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>adjoint</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `params` | variadic of 64-bit float |
| `in_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_values` | variadic of 1-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |
| `out_ctrl_qubits` | variadic of A value-semantic qubit (state). |


### `quantum.dealloc` (::catalyst::quantum::DeallocOp)

_Deallocate a quantum register._

Syntax:

```
operation ::= `quantum.dealloc` $qreg attr-dict `:` type(operands)
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `qreg` | An array of value-semantic qubits (i.e. quantum register). |


### `quantum.dealloc_qb` (::catalyst::quantum::DeallocQubitOp)

_Deallocate a single qubit._

Syntax:

```
operation ::= `quantum.dealloc_qb` $qubit attr-dict `:` type(operands)
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `qubit` | A value-semantic qubit (state). |


### `quantum.device` (::catalyst::quantum::DeviceInitOp)

_Initialize a quantum device._

Syntax:

```
operation ::= `quantum.device` (`shots` `(` $shots^ `)`)? `[` $lib `,` $device_name `,` $kwargs `]` attr-dict
```

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>auto_qubit_management</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>lib</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>device_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>kwargs</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `shots` | 64-bit signless integer |


### `quantum.device_release` (::catalyst::quantum::DeviceReleaseOp)

_Release the active quantum device._

Syntax:

```
operation ::= `quantum.device_release` attr-dict
```


### `quantum.expval` (::catalyst::quantum::ExpvalOp)

_Compute the expectation value of the given observable for the current state_

Syntax:

```
operation ::= `quantum.expval` $obs attr-dict `:` type(results)
```

The `quantum.expval` operation represents the measurement process of computing the
expectation value of an observable on the current quantum state. While this quantity can
be computed analytically on simulators, for hardware execution or shot noise
simulation, the shots attached to the device
in the local scope is used.
The only SSA argument is an observable that must be defined by an operation in the local
scope.

Example:

```mlir
func.func @foo(%q: !quantum.bit)
{
    %obs = quantum.namedobs %q[4] : !quantum.obs
    %expval = quantum.expval %obs : f64

    func.return
}
```

Interfaces: `MeasurementProcess`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `obs` | A quantum observable for use in measurements. |

#### Results:

| Result | Description |
| :----: | ----------- |
| `expval` | 64-bit float |


### `quantum.extract` (::catalyst::quantum::ExtractOp)

_Extract a qubit value from a register._

Syntax:

```
operation ::= `quantum.extract` $qreg `[` ($idx^):($idx_attr)? `]` attr-dict `:` type($qreg) `->` type(results)
```

Interfaces: `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>idx_attr</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is non-negative</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `qreg` | An array of value-semantic qubits (i.e. quantum register). |
| `idx` | 64-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `qubit` | A value-semantic qubit (state). |


### `quantum.finalize` (::catalyst::quantum::FinalizeOp)

_Teardown the quantum runtime._

Syntax:

```
operation ::= `quantum.finalize` attr-dict
```

Executing this instruction concretely corresponds to executing the
``__catalyst__rt__finalize`` function in the runtime which is expected
to be the very last thing executed by the library.


### `quantum.gphase` (::catalyst::quantum::GlobalPhaseOp)

_Global Phase._

Syntax:

```
operation ::= `quantum.gphase` `(` $params `)` attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` (`ctrls` type($out_ctrl_qubits)^ )?
```

Applies global phase to the current system.

Traits: `AttrSizedOperandSegments`, `Unitary`

Interfaces: `DifferentiableGate`, `ParametrizedGate`, `QuantumGate`, `QuantumOperation`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>adjoint</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `params` | 64-bit float |
| `in_ctrl_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_values` | variadic of 1-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_ctrl_qubits` | variadic of A value-semantic qubit (state). |


### `quantum.hamiltonian` (::catalyst::quantum::HamiltonianOp)

_Define a Hamiltonian observable for use in measurements_

Syntax:

```
operation ::= `quantum.hamiltonian` `(` $coeffs `:` type($coeffs) `)` $terms attr-dict `:` type(results)
```

The `quantum.hamiltonian` operation defines a quantum observable to be used by other
operations such as measurement processes. The specific observable defined here represents
the hamiltonian of observables. The arguments are a set of coefficients and a set of
`quantum.Observable` generated by `quantum.namedobs`, `quantum.hermitian`,
or `quantum.tensorobs`.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %c: tensor<2xf64>) {
    %obs1 = quantum.namedobs %q0[4] : !quantum.obs
    %obs2 = quantum.namedobs %q1[2] : !quantum.obs
    %res = quantum.hamiltonian(%c: tensor<2xf64>) %obs1, %obs2 : !quantum.obs
    func.return
}
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `coeffs` | 1D tensor of 64-bit float values or 1D memref of 64-bit float values |
| `terms` | variadic of A quantum observable for use in measurements. |

#### Results:

| Result | Description |
| :----: | ----------- |
| `obs` | A quantum observable for use in measurements. |


### `quantum.hermitian` (::catalyst::quantum::HermitianOp)

_Define a Hermitian observable for use in measurements_

Syntax:

```
operation ::= `quantum.hermitian` `(` $matrix `:` type($matrix) `)` $qubits attr-dict `:` type(results)
```

The `quantum.hermitian` operation defines a quantum observable to be used by measurement
processes. The specific observable defined here represents the Hermitian observable on a
set of qubits. The arguments are a set of qubits to measure as well as a row-major flatten
matrix of complex numbers that represents a Hermitian matrix that must be of size
2^(number of qubits) * 2^(number of qubits).

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `matrix` | 2D tensor of complex type with 64-bit float elements values or 2D memref of complex type with 64-bit float elements values |
| `qubits` | variadic of A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `obs` | A quantum observable for use in measurements. |


### `quantum.init` (::catalyst::quantum::InitializeOp)

_Initialize the quantum runtime._

Syntax:

```
operation ::= `quantum.init` attr-dict
```

The execution of this operation corresponds to the execution of Catalyst's runtime function
``__catalyst__rt__initialize`` which is the first function that will be called for the duration
of the whole compiled object.


### `quantum.insert` (::catalyst::quantum::InsertOp)

_Update the qubit value of a register._

Syntax:

```
operation ::= `quantum.insert` $in_qreg `[` ($idx^):($idx_attr)? `]` `,` $qubit attr-dict `:` type($in_qreg) `,` type($qubit)
```

Interfaces: `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>idx_attr</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is non-negative</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `in_qreg` | An array of value-semantic qubits (i.e. quantum register). |
| `idx` | 64-bit signless integer |
| `qubit` | A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qreg` | An array of value-semantic qubits (i.e. quantum register). |


### `quantum.measure` (::catalyst::quantum::MeasureOp)

_A single-qubit projective measurement in the computational basis._

Syntax:

```
operation ::= `quantum.measure` $in_qubit (`postselect` $postselect^)? attr-dict `:` type(results)
```

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>postselect</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0 whose maximum value is 1</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `in_qubit` | A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `mres` | 1-bit signless integer |
| `out_qubit` | A value-semantic qubit (state). |


### `quantum.multirz` (::catalyst::quantum::MultiRZOp)

_Apply an arbitrary multi Z rotation_

Syntax:

```
operation ::= `quantum.multirz` `(` $theta `)` $in_qubits (`adj` $adjoint^)? attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
```

The `quantum.multirz` operation applies an arbitrary multi Z rotation to the state-vector.
The arguments are the rotation angle `theta` and a set of qubits the operation acts on.

.. note::
    This operation is one of the few quantum operations that is not applied via
    ``quantum.custom``. The reason for this is that it needs to be handled in a special
    way during the lowering due to its C function being variadic on the number of qubits.

Traits: `AttrSizedOperandSegments`, `AttrSizedResultSegments`, `Unitary`

Interfaces: `DifferentiableGate`, `NoMemoryEffect (MemoryEffectOpInterface)`, `ParametrizedGate`, `QuantumGate`, `QuantumOperation`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>adjoint</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `theta` | 64-bit float |
| `in_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_values` | variadic of 1-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |
| `out_ctrl_qubits` | variadic of A value-semantic qubit (state). |


### `quantum.namedobs` (::catalyst::quantum::NamedObsOp)

_Define a Named observable for use in measurements_

Syntax:

```
operation ::= `quantum.namedobs` $qubit `[` $type `]` attr-dict  `:` type(results)
```

The `quantum.namedobs` operation defines a quantum observable to be used by measurement
processes. The specific observable defined here represents one of 5 named observables
{Identity, PauliX, PauliY, PauliZ, Hadamard} on a qubit. The arguments are a qubit to
measure as well as an encoding operator for the qubit as an integer between 0-4.

Example:

```mlir
func.func @foo(%q: !quantum.bit)
{
    %res = quantum.namedobs %q[4] : !quantum.obs
    func.return
}
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>type</code></td><td>::catalyst::quantum::NamedObservableAttr</td><td>Known named observables</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `qubit` | A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `obs` | A quantum observable for use in measurements. |


### `quantum.num_qubits` (::catalyst::quantum::NumQubitsOp)

_Get the number of currently allocated qubits._

Syntax:

```
operation ::= `quantum.num_qubits` attr-dict `:` type(results)
```

#### Results:

| Result | Description |
| :----: | ----------- |
| `num_qubits` | 64-bit signless integer |


### `quantum.probs` (::catalyst::quantum::ProbsOp)

_Compute computational basis probabilities for the current state_

Syntax:

```
operation ::= `quantum.probs` $obs ( `shape` $dynamic_shape^ )?
              ( `in` `(` $state_in^ `:` type($state_in) `)` )?
              attr-dict ( `:` type($probabilities)^ )?
```

The `quantum.probs` operation represents the measurement process of computing probabilities
for measurement outcomes in the computational basis for a set of qubits.
Marginal probabilities are supported, that is the provided qubits do not need to make up the
entire statevector.
The result array contains one element for each possible bitstring, i.e. 2^n where n is the
number of qubits.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit)
{
    %probs = quantum.probs %q0, %q1 : tensor<4xf64>
    func.return
}
```

.. note::

    The optional operand ``state_in`` is only used after bufferization.

Traits: `AttrSizedOperandSegments`

Interfaces: `MeasurementProcess`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `obs` | A quantum observable for use in measurements. |
| `dynamic_shape` | 64-bit signless integer |
| `state_in` | 1D memref of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `probabilities` | 1D tensor of 64-bit float values |


### `quantum.unitary` (::catalyst::quantum::QubitUnitaryOp)

_Apply an arbitrary fixed unitary matrix_

Syntax:

```
operation ::= `quantum.unitary` `(` $matrix `:` type($matrix) `)` $in_qubits (`adj` $adjoint^)? attr-dict ( `ctrls` `(` $in_ctrl_qubits^ `)` )?  ( `ctrlvals` `(` $in_ctrl_values^ `)` )? `:` type($out_qubits) (`ctrls` type($out_ctrl_qubits)^ )?
```

The `quantum.unitary` operation applies an arbitrary fixed unitary matrix to the
state-vector. The arguments are a set of qubits and a 2-dim matrix of complex numbers
that represents a Unitary matrix of size 2^(number of qubits) * 2^(number of qubits).

Traits: `AttrSizedOperandSegments`, `AttrSizedResultSegments`, `Unitary`

Interfaces: `NoMemoryEffect (MemoryEffectOpInterface)`, `ParametrizedGate`, `QuantumGate`, `QuantumOperation`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>adjoint</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `matrix` | 2D tensor of complex type with 64-bit float elements values or 2D memref of complex type with 64-bit float elements values |
| `in_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_qubits` | variadic of A value-semantic qubit (state). |
| `in_ctrl_values` | variadic of 1-bit signless integer |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |
| `out_ctrl_qubits` | variadic of A value-semantic qubit (state). |


### `quantum.sample` (::catalyst::quantum::SampleOp)

_Sample eigenvalues from the given observable for the current state_

Syntax:

```
operation ::= `quantum.sample` $obs ( `shape` $dynamic_shape^ )?
              ( `in` `(` $in_data^ `:` type($in_data) `)` )?
              attr-dict ( `:` type($samples)^ )?
```

The `quantum.sample` operation represents the measurement process of sampling eigenvalues
from an observable on the current quantum state.
The only SSA argument is an observable that must be defined by an operation in the local scope.
from an observable on the current quantum state.
The number of samples to draw is determined by the device shots argument in the device initialization operation in the local scope.


Note that the return value type depends on the type of observable provided. Computational
basis samples are returned as a 2D array of shape (shot number, number of qubits), with all
other obversables the output is a 1D array of lenth equal to the shot number.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
{
    quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
    %obs1 = quantum.compbasis %q0, %q1 : !quantum.obs
    %samples = quantum.sample %obs1 : tensor<?xf64>

    %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
    %samples2 = quantum.sample %obs2 : tensor<?x2xf64>

    func.return
}
```

.. note::

    The return value type depends on the type of observable provided. Computational
    basis samples are returned as a 2D array of shape (shot number, number of qubits), with all
    other obversables the output is a 1D array of lenth equal to the shot number.

.. note::

    The ``in_data`` field is needed only after bufferization. It is an implementation detail that
    transform writers are unlikely to be worried about.

Traits: `AttrSizedOperandSegments`

Interfaces: `MeasurementProcess`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `obs` | A quantum observable for use in measurements. |
| `dynamic_shape` | variadic of 64-bit signless integer |
| `in_data` | 1D memref of 64-bit float values or 2D memref of 64-bit float values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `samples` | 1D tensor of 64-bit float values or 2D tensor of 64-bit float values |


### `quantum.set_basis_state` (::catalyst::quantum::SetBasisStateOp)

_Set basis state._

Syntax:

```
operation ::= `quantum.set_basis_state` `(` $basis_state`)` $in_qubits attr-dict `:` functional-type(operands, results)
```

This operation is useful for simulators implementing set basis state.
Instead of decomposing basis state into multiple operations, this
operation shortcuts all of that into a single operation.
This signature matches the one in pennylane-lightning which expects
only a single integer as opposed to a binary digit.

Interfaces: `QuantumOperation`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `basis_state` | 1D tensor of 1-bit signless integer values or 1D memref of 1-bit signless integer values |
| `in_qubits` | variadic of A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `quantum.set_state` (::catalyst::quantum::SetStateOp)

_Set state to a complex vector._

Syntax:

```
operation ::= `quantum.set_state` `(` $in_state `)` $in_qubits attr-dict `:` functional-type(operands, results)
```

This operation is useful for simulators implementing state preparation.
Instead of decomposing state preparation into multiple operations, this
operation shortcuts all of that into a single operation.

Interfaces: `QuantumOperation`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `in_state` | 1D tensor of complex type with 64-bit float elements values or 1D memref of complex type with 64-bit float elements values |
| `in_qubits` | variadic of A value-semantic qubit (state). |

#### Results:

| Result | Description |
| :----: | ----------- |
| `out_qubits` | variadic of A value-semantic qubit (state). |


### `quantum.state` (::catalyst::quantum::StateOp)

_Return the current statevector_

Syntax:

```
operation ::= `quantum.state` $obs ( `shape` $dynamic_shape^ )?
              ( `in` `(` $state_in^ `:` type($state_in) `)` )?
              attr-dict ( `:` type($state)^ )?
```

The `quantum.state` operation represents the measurement process of returning the current
statevector in the computational basis. Typically reserved for simulator devices, although
in principle also achievable on hardware via tomography techniques.
While marginal states are supported, the operation is only well-defined if the provided
qubits are not entangled with the rest of the quantum state.
The result array contains one (complex) element for each possible bitstring, i.e. 2^n where
n is the number of qubits.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit)
{
    %obs = quantum.compbasis qubits %q0, %q1 : !quantum.obs
    %state = quantum.state %obs : tensor<4xcomplex<f64>>
    func.return
}
```

Traits: `AttrSizedOperandSegments`

Interfaces: `MeasurementProcess`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `obs` | A quantum observable for use in measurements. |
| `dynamic_shape` | 64-bit signless integer |
| `state_in` | 1D memref of complex type with 64-bit float elements values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `state` | 1D tensor of complex type with 64-bit float elements values |


### `quantum.tensor` (::catalyst::quantum::TensorOp)

_Define a tensor product of observables for use in measurements_

Syntax:

```
operation ::= `quantum.tensor` $terms attr-dict `:` type(results)
```

The `quantum.tensor` operation defines a quantum observable to be used by other
operations such as measurement processes. The specific observable defined here represents
the tensor product of observables on a set of qubits. The arguments are a set of
`quantum.Observable` generated by `quantum.namedobs` and `quantum.hermitian`.

Example:

```mlir
func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %m: tensor<2x2xcomplex<f64>>)
{
    %obs1 = quantum.namedobs %q0[4] : !quantum.obs
    %obs2 = quantum.hermitian(%m: tensor<2x2xcomplex<f64>>) %q1 : !quantum.obs
    %res = quantum.tensorprod %obs1, %obs2 : !quantum.obs
    func.return
}
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `terms` | variadic of A quantum observable for use in measurements. |

#### Results:

| Result | Description |
| :----: | ----------- |
| `obs` | A quantum observable for use in measurements. |


### `quantum.var` (::catalyst::quantum::VarianceOp)

_Compute the variance of the given observable for the current state_

Syntax:

```
operation ::= `quantum.var` $obs attr-dict `:` type(results)
```

The `quantum.var` operation represents the measurement process of computing the variance of
an observable on the current quantum state. While this quantity can be computed analytically on simulators, for hardware execution or shot noise
simulation, the shots attached to the device
in the local scope is used.
The only SSA argument is an observable that must be defined by an operation in the local
scope.

Example:

```mlir
func.func @foo(%q: !quantum.bit)
{
    %obs = quantum.namedobs %q[4] : !quantum.obs
    %var = quantum.var %obs : f64

    func.return
}
```

Interfaces: `MeasurementProcess`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `obs` | A quantum observable for use in measurements. |

#### Results:

| Result | Description |
| :----: | ----------- |
| `variance` | 64-bit float |


### `quantum.yield` (::catalyst::quantum::YieldOp)

_Return results from quantum program regions_

Syntax:

```
operation ::= `quantum.yield` attr-dict ($retvals ^ `:` type($retvals))?
```

Traits: `AlwaysSpeculatableImplTrait`, `HasParent<AdjointOp>`, `ReturnLike`, `Terminator`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `retvals` | variadic of An array of value-semantic qubits (i.e. quantum register). |

