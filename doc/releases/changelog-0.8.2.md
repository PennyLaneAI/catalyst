# Release 0.8.2

<h3>New features</h3>

* Shot-vector support for Catalyst: Introduces support for shot-vectors in Catalyst, currently available for
  `qml.sample` measurements in the `lightning.qubit` device. Shot-vectors now allow elements of the form
  `((20, 5),)`, which is equivalent to `(20,)*5` or `(20, 20, 20, 20, 20)`. Furthermore, multiple `qml.sample`
  calls can now be returned from the same program, and can be structured using Python containers. For example,
  a program can return a dictionary like `return {"first": qml.sample(), "second": qml.sample()}`.
  [(#1051)](https://github.com/PennyLaneAI/catalyst/pull/1051)

* A new function `catalyst.passes.pipeline` allows the quantum circuit transformation pass pipeline for QNodes within a qjit-compiled workflow to be configured.
  [(#1131)](https://github.com/PennyLaneAI/catalyst/pull/1131)

  ```python
    my_passes = {
        "cancel_inverses": {},
        "my_circuit_transformation_pass": {"my-option" : "my-option-value"},
    }
    dev = qml.device("lightning.qubit", wires=2)

    @pipeline(my_passes)
    @qnode(dev)
    def circuit(x):
        qml.RX(x, wires=0)
        return qml.expval(qml.PauliZ(0))

    @qjit
    def fn(x):
        return jnp.sin(circuit(x ** 2))
  ```

  `pipeline` can also be used to specify different pass pipelines for different parts of the
  same qjit-compiled workflow:

  ```python
    my_pipeline = {
        "cancel_inverses": {},
        "my_circuit_transformation_pass": {"my-option" : "my-option-value"},
    }

    my_other_pipeline = {"cancel_inverses": {}}

    @qjit
    def fn(x):
        circuit_pipeline = pipeline(my_pipeline)(circuit)
        circuit_other = pipeline(my_other_pipeline)(circuit)
        return jnp.abs(circuit_pipeline(x) - circuit_other(x))
  ```

  For a list of available passes, please see the [catalyst.passes module documentation](https://docs.pennylane.ai/projects/catalyst/en/stable/code/__init__.html#module-catalyst.passes).

  The pass pipeline order and options can be configured *globally* for a
  qjit-compiled function, by using the `circuit_transform_pipeline` argument of the :func:`~.qjit` decorator.

  ```python
    my_passes = {
        "cancel_inverses": {},
        "my_circuit_transformation_pass": {"my-option" : "my-option-value"},
    }

    @qjit(circuit_transform_pipeline=my_passes)
    def fn(x):
        return jnp.sin(circuit(x ** 2))
  ```

  Global and local (via `@pipeline`) configurations can coexist, however local pass pipelines
  will always take precedence over global pass pipelines.

  Available MLIR passes are now documented and available within the
  [catalyst.passes module documentation](https://docs.pennylane.ai/projects/catalyst/en/stable/code/__init__.html#module-catalyst.passes).

<h3>Improvements</h3>

* Scalar tensors are eliminated from control flow operations in the program, and are replaced with
  bare scalars instead. This improves compilation time and memory usage at runtime by avoiding heap
  allocations and reducing the amount of instructions.
  [(#1075)](https://github.com/PennyLaneAI/catalyst/pull/1075)

  A new MLIR pass `detensorize-scf` is added that works in conjuction with the existing
  `linalg-detensorize` pass to detensorize input programs. The IR generated by JAX wraps all values
  in the program in tensors, including scalars, leading to unnecessary memory allocations for
  programs compiled to CPU via MLIR to LLVM pipeline.

* Bufferization of `gradient.ForwardOp` and `gradient.ReverseOp` now requires 3 steps: `gradient-preprocessing`, 
  `gradient-bufferize`, and `gradient-postprocessing`. `gradient-bufferize` has a new rewrite for `gradient.ReturnOp`. 
  [(#1139)](https://github.com/PennyLaneAI/catalyst/pull/1139)

* Importing Catalyst will now pollute less of JAX's global variables by using `LoweringParameters`.
  [(#1152)](https://github.com/PennyLaneAI/catalyst/pull/1152)

* Cached primitive lowerings is used instead of a custom cache structure.
  [(#1159)](https://github.com/PennyLaneAI/catalyst/pull/1159)

<h3>Internal changes</h3>

* Remove the `MemMemCpyOptPass` in llvm O2 (applied for Enzyme), this reduces bugs when 
  running gradient like functions.
  [(#1063)](https://github.com/PennyLaneAI/catalyst/pull/1063)

* Functions with multiple tapes are now split with a new mlir pass `--split-multiple-tapes`, with one tape per function. 
  The reset routine that makes a maeasurement between tapes and inserts a X gate if measured one is no longer used.
  [(#1017)](https://github.com/PennyLaneAI/catalyst/pull/1017)
  [(#1130)](https://github.com/PennyLaneAI/catalyst/pull/1130)

* Catalyst now generates nested modules denoting quantum programs.
  [(#1144)](https://github.com/PennyLaneAI/catalyst/pull/1144)

  Similar to MLIR's `gpu.launch_kernel` function, Catalyst, now supports
  a `call_function_in_module`. This allows Catalyst to call functions in modules
  and have modules denote a quantum kernel. This will allow for device specific
  optimizations and compilation pipelines.

  At the moment, no one is using this. This is just the necessary scaffolding to
  supporting device specific transformations. As such, the module will be inlined
  to preserve current semantics. However, in the future, we will explore lowering
  this nested module into other IRs/binary formats and lowering `call_function_in_module`
  to something that can dispatch calls to another runtime / VM.

<h3>Bug fixes</h3>

* Resolve a bug where `mitigate_with_zne` does not work properly with shots and devices 
  supporting only Counts and Samples (e.g. Qrack). (transform: `measurements_from_sample`).
  [(#1165)](https://github.com/PennyLaneAI/catalyst/pull/1165)

<h3>Contributors</h3>

This release contains contributions from (in alphabetical order):

David Ittah,
Paul Haochen Wang,
Romain Moyard,
Erick Ochoa Lopez,
Raul Torres,
Tzung-Han Juang.
