// Copyright 2023 Xanadu Quantum Technologies Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef CATALYST_PASSES
#define CATALYST_PASSES

include "mlir/Pass/PassBase.td"

def CatalystBufferizationPass : Pass<"catalyst-bufferize"> {
    let summary = "Bufferize tensors in catalyst utility ops.";

    let dependentDialects = [
        "bufferization::BufferizationDialect",
        "memref::MemRefDialect",
        "index::IndexDialect"
    ];

    let constructor = "catalyst::createCatalystBufferizationPass()";
}

def ArrayListToMemRefPass : Pass<"convert-arraylist-to-memref"> {
    let summary = "Lower array list operations to memref operations.";
    let description = [{
        This pass implements dynamically resizable array lists via lowering
        them to mutable memrefs.
    }];

    let dependentDialects = [
        "mlir::arith::ArithDialect",
        "mlir::func::FuncDialect",
        "mlir::memref::MemRefDialect",
        "mlir::scf::SCFDialect"
    ];

    let constructor = "catalyst::createArrayListToMemRefPass()";
}

def CatalystConversionPass : Pass<"convert-catalyst-to-llvm"> {
    let summary = "Lower catalyst utility operations to the LLVM dialect.";

    let dependentDialects = [
        "mlir::func::FuncDialect",
        "mlir::LLVM::LLVMDialect",
    ];

    let constructor = "catalyst::createCatalystConversionPass()";
}

def ScatterLoweringPass : Pass<"scatter-lowering"> {
    let summary = "Lower scatter op from Stable HLO to loops.";

    let dependentDialects = [
        "index::IndexDialect",
        "mhlo::MhloDialect",
        "scf::SCFDialect"
    ];

    let constructor = "catalyst::createScatterLoweringPass()";
}

def HloCustomCallLoweringPass : Pass<"hlo-custom-call-lowering"> {
    let summary = "Lower custom calls op from Stable HLO to CallOp.";

    let dependentDialects = [
        "index::IndexDialect",
        "mlir::func::FuncDialect",
        "catalyst::CatalystDialect",
    ];

    let constructor = "catalyst::createHloCustomCallLoweringPass()";
}

def QnodeToAsyncLoweringPass : Pass<"qnode-to-async-lowering"> {
    let summary = "Lower Qnode func and call operations to async func and call operations.";

    let dependentDialects = [
        "async::AsyncDialect",
        "mlir::memref::MemRefDialect",
        "bufferization::BufferizationDialect"
    ];

    let constructor = "catalyst::QnodeToAsyncLoweringPass()";
}

def DisableAssertionPass : Pass<"disable-assertion"> {
    let summary = "Disable all catalyst_assertions.";

    let constructor = "catalyst::createDisableAssertionPass()";
}

def AddExceptionHandlingPass : Pass<"add-exception-handling"> {
    let summary = "Adds exception handling for async qnodes.";

    let description = [{
        This pass will set async tokens and async values to be an error
        when qnodes raise an exception.

        Besides that, it will change the logic generated by the async dialect
        that aborts the execution and instead will call a function in the runtime
        that will generate an error.
    }];

    let dependentDialects = [
        "mlir::LLVM::LLVMDialect",
    ];

    let constructor = "catalyst::createAddExceptionHandlingPass()";

    let options = [
        Option<
            /*C++ var name=*/"stopAfterStep",
            /*CLI arg name=*/"stop-after-step",
            /*type=*/"int",
            /*default=*/"0",
            /*description=*/
            "Useful for tests. This will stop the execution of the transformation after a "
            "N step has been executed. Defaults to 0 which is equivalent to running "
            "all steps to completion."
        >
    ];
}

def GEPInboundsPass : Pass<"gep-inbounds"> {
    let summary = "Mark GEPOp inbounds.";

    let constructor = "catalyst::GEPInboundsPass()";
}

def MemrefCopyToLinalgCopyPass : Pass<"memrefcpy-to-linalgcpy"> {
    let summary = "Switch memref.copy to linalg.copy when the layout is not the identity.";
    
    let dependentDialects = [
        "memref::MemRefDialect",
        "linalg::LinalgDialect"
    ];

    let constructor = "catalyst::MemrefCopyToLinalgCopyPass()";
}

def RegisterInactiveCallbackPass : Pass<"register-inactive-callback", "ModuleOp"> {
    let summary = "Register `__catalyst_inactive_callback` as inactive with Enzyme";

    let dependentDialects = [
        "mlir::LLVM::LLVMDialect"
    ];

    let constructor = "catalyst::createRegisterInactiveCallbackPass()";

}

def ApplyTransformSequencePass : Pass<"apply-transform-sequence"> {
    let summary = "Apply the passes scheduled with the transform dialect.";

    let constructor = "catalyst::createApplyTransformSequencePass()";
}

def MyHelloWorldPass : Pass<"my-hello-world"> {
    let summary = "An empty pass boilerplate that prints out hello world.";

    let constructor = "catalyst::createMyHelloWorldPass()";
}

#endif // CATALYST_PASSES
