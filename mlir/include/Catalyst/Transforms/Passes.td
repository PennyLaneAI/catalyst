// Copyright 2023 Xanadu Quantum Technologies Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef CATALYST_PASSES
#define CATALYST_PASSES

include "mlir/Pass/PassBase.td"

def CatalystBufferizationPass : Pass<"catalyst-bufferize"> {
    let summary = "Bufferize tensors in catalyst utility ops.";

    let dependentDialects = [
        "bufferization::BufferizationDialect",
        "memref::MemRefDialect",
        "index::IndexDialect"
    ];

    let constructor = "catalyst::createCatalystBufferizationPass()";
}

def ArrayListToMemRefPass : Pass<"convert-arraylist-to-memref"> {
    let summary = "Lower array list operations to memref operations.";
    let description = [{
        This pass implements dynamically resizable array lists via lowering
        them to mutable memrefs.
    }];

    let dependentDialects = [
        "mlir::arith::ArithDialect",
        "mlir::func::FuncDialect",
        "mlir::memref::MemRefDialect",
        "mlir::scf::SCFDialect"
    ];

    let constructor = "catalyst::createArrayListToMemRefPass()";
}

def CatalystConversionPass : Pass<"convert-catalyst-to-llvm"> {
    let summary = "Lower catalyst utility operations to the LLVM dialect.";

    let dependentDialects = [
        "mlir::LLVM::LLVMDialect",
    ];

    let constructor = "catalyst::createCatalystConversionPass()";
}

def ScatterLoweringPass : Pass<"scatter-lowering"> {
    let summary = "Lower scatter op from Stable HLO to loops.";

    let dependentDialects = [
        "index::IndexDialect",
        "mhlo::MhloDialect",
        "scf::SCFDialect"
    ];

    let constructor = "catalyst::createScatterLoweringPass()";
}

def HloCustomCallLoweringPass : Pass<"hlo-custom-call-lowering"> {
    let summary = "Lower custom calls op from Stable HLO to CallOp.";

    let dependentDialects = [
        "index::IndexDialect",
        "mlir::func::FuncDialect",
        "catalyst::CatalystDialect",
    ];

    let constructor = "catalyst::createHloCustomCallLoweringPass()";
}

def QnodeToAsyncLoweringPass : Pass<"qnode-to-async-lowering"> {
    let summary = "Lower Qnode func and call operations to async func and call operations.";

    let dependentDialects = [
        "async::AsyncDialect",
        "mlir::memref::MemRefDialect",
        "bufferization::BufferizationDialect"
    ];

    let constructor = "catalyst::QnodeToAsyncLoweringPass()";
}

def AddExceptionHandlingPass : Pass<"add-exception-handling"> {
    let summary = "Adds exception handling for async qnodes.";

    let description = [{
        This pass will set async tokens and async values to be an error
        when qnodes raise an exception.

        Besides that, it will change the logic generated by the async dialect
        that aborts the execution and instead will call a function in the runtime
        that will generate an error.
    }];

    let dependentDialects = [
        "mlir::LLVM::LLVMDialect",
    ];

    let constructor = "catalyst::createAddExceptionHandlingPass()";

    let options = [
        Option<
            /*C++ var name=*/"stopAfterStep",
            /*CLI arg name=*/"stop-after-step",
            /*type=*/"int",
            /*default=*/"0",
            /*description=*/
            "Useful for tests. This will stop the execution of the transformation after a "
            "N step has been executed. Defaults to 0 which is equivalent to running "
            "all steps to completion."
        >
    ];
}

def GEPInboundsPass : Pass<"gep-inbounds"> {
    let summary = "Mark GEPOp inbounds.";

    let constructor = "catalyst::GEPInboundsPass()";
}

def AnnotateDebugCallbackAsEnzymeConstPass : Pass<"annotate-debug-callback-as-enzyme-const", "ModuleOp"> {
    let summary = "Annotates debug callbacks as enzyme_const";

    let description = [{

        This pass will:
           1. Find all call sites to `pyregistry`.
           2. Determine if the call to `pyregistry` corresponds to a `debug.callback`
           3. Mark all parameters as `enzyme_const`.


         Step 1:
           At the LLVM stage, call sites to `pyregistry` correspond to call sites to
           any callback implementation.

         Step 2:
           The callback calling convention is as follows:

           1. The first parameter is the identifier.
           2. The second parameter is the number of parameters.
           3. The third parameter is the number of returned values.
           4. The arguments that follow are variable arguments.
           5. These three parameters are known at compile time.

           Therefore, a callback with its third parameter set to zero is a callback without
           returns. This means that a call site to `pyregistry` with its third parameter set
           to zero corresponds to the notion of a `debug.callback` in the front end.

         Step 3:
           From EnzymeAD's documentation:

               Inactive arguments are given enzyme_const metadata;
               - https://enzyme.mit.edu/getting_started/CallingConvention/#types
    }];

    let dependentDialects = [
        "mlir::LLVM::LLVMDialect"
    ];

    let constructor = "catalyst::createAnnotateDebugCallbackAsEnzymeConstPass()";

}

#endif // CATALYST_PASSES
