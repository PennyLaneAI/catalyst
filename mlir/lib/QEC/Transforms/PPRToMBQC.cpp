// Copyright 2025 Xanadu Quantum Technologies Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <mlir/Dialect/Arith/IR/Arith.h>

#include "QEC/IR/QECOps.h"
#include "QEC/Transforms/Patterns.h"
#include "QEC/Utils/PauliStringWrapper.h"
#include "Quantum/IR/QuantumOps.h"

using namespace mlir;
using namespace catalyst;
using namespace catalyst::quantum;
using namespace catalyst::qec;

namespace {

CustomOp buildCNOTGate(Value control, Value target, ConversionPatternRewriter &rewriter)
{
    return rewriter.create<quantum::CustomOp>(
        control.getLoc(),
        /*out_qubits=*/mlir::TypeRange({control.getType(), target.getType()}),
        /*out_ctrl_qubits=*/mlir::TypeRange({}),
        /*params=*/mlir::ValueRange(),
        /*in_qubits=*/mlir::ValueRange({control, target}),
        /*gate_name=*/"CNOT",
        /*adjoint=*/false,
        /*in_ctrl_qubits=*/mlir::ValueRange({}),
        /*in_ctrl_values=*/mlir::ValueRange());
}

// Overload for static (compile-time) parameters
CustomOp buildSingleQubitGate(Value qubit, StringRef gateName, ArrayRef<double> params,
                              ConversionPatternRewriter &rewriter)
{
    SmallVector<Value, 1> paramValues;
    auto f64Ty = rewriter.getF64Type();
    for (double p : params) {
        auto cst = rewriter.create<mlir::arith::ConstantOp>(qubit.getLoc(), f64Ty,
                                                            rewriter.getF64FloatAttr(p));
        paramValues.push_back(cst.getResult());
    }

    return rewriter.create<quantum::CustomOp>(qubit.getLoc(),
                                              /*out_qubits=*/mlir::TypeRange({qubit.getType()}),
                                              /*out_ctrl_qubits=*/mlir::TypeRange({}),
                                              /*params=*/mlir::ValueRange(paramValues),
                                              /*in_qubits=*/mlir::ValueRange({qubit}),
                                              /*gate_name=*/gateName,
                                              /*adjoint=*/false,
                                              /*in_ctrl_qubits=*/mlir::ValueRange({}),
                                              /*in_ctrl_values=*/mlir::ValueRange());
}

// Version for dynamic (runtime) parameters
CustomOp buildSingleQubitGateWithDynamicParams(Value qubit, StringRef gateName, ValueRange params,
                                               ConversionPatternRewriter &rewriter)
{
    return rewriter.create<quantum::CustomOp>(qubit.getLoc(),
                                              /*out_qubits=*/mlir::TypeRange({qubit.getType()}),
                                              /*out_ctrl_qubits=*/mlir::TypeRange({}),
                                              /*params=*/params,
                                              /*in_qubits=*/mlir::ValueRange({qubit}),
                                              /*gate_name=*/gateName,
                                              /*adjoint=*/false,
                                              /*in_ctrl_qubits=*/mlir::ValueRange({}),
                                              /*in_ctrl_values=*/mlir::ValueRange());
}

MeasureOp buildMeasurementOp(Value qubit, ConversionPatternRewriter &rewriter)
{
    return rewriter.create<quantum::MeasureOp>(qubit.getLoc(),
                                               /*mres=*/rewriter.getI1Type(),
                                               /*out_qubits=*/qubit.getType(),
                                               /*in_qubits=*/qubit,
                                               /*postselect=*/nullptr);
}

// Applies per-qubit conjugations that map the provided Pauli string to the Z
// basis. If `isReverse` is true, applies the inverse mapping.
void constructPauliConjugationLayer(SmallVector<Value> &qubits, ArrayRef<StringRef> pauliString,
                                    bool isReverse, ConversionPatternRewriter &rewriter)
{
    // Apply the conjugation gate on the corresponding qubit index.
    // Expect the Pauli string length to match the number of qubits.
    size_t numQubits = qubits.size();

    for (size_t idx = 0; idx < numQubits; idx++) {
        switch (pauliString[idx].front()) {
        case 'X': {
            qubits[idx] =
                buildSingleQubitGate(qubits[idx], "Hadamard", {}, rewriter).getOutQubits().front();
            break;
        }
        case 'Y': {
            // These parameters values are generated by @convert_to_mbqc_gateset from PennyLane.
            // Currently, these params are hardcoded because there are only two possible values for
            // Y Pauli, and it would be tedious to write a function to generate them.
            // ─────RotXZX(11.33,0.00,2.80)────RZ(PHI/2)────RotXZX(1.23,0.00,9.76)────
            auto params = !isReverse ? std::array<double, 3>({11.33, 0.00, 2.80})
                                     : std::array<double, 3>({1.23, 0.00, 9.76});
            qubits[idx] = buildSingleQubitGate(qubits[idx], "RotXZX", params, rewriter)
                              .getOutQubits()
                              .front();
            break;
        }
        case 'I':
            [[fallthrough]];
        case 'Z': {
            // No action needed for I/Z when mapping to Z-basis.
            break;
        }
        }
    }
}

// Applies a right-to-left CNOT ladder to accumulate parity onto `qubits[0]`.
void constructCNOTLadder(SmallVector<Value> &qubits, ConversionPatternRewriter &rewriter)
{
    size_t numQubits = qubits.size();
    for (size_t i = numQubits - 1; i > 0; i--) {
        auto outQubits = buildCNOTGate(qubits[i], qubits[i - 1], rewriter).getOutQubits();
        qubits[i] = outQubits[0];
        qubits[i - 1] = outQubits[1];
    }
}

// Reverses the CNOT ladder to uncompute parity accumulation.
void constructReverseCNOTLadder(SmallVector<Value> &qubits, ConversionPatternRewriter &rewriter)
{
    size_t numQubits = qubits.size();
    for (size_t i = 0; i < numQubits - 1; i++) {
        auto outQubits = buildCNOTGate(qubits[i + 1], qubits[i], rewriter).getOutQubits();
        qubits[i] = outQubits[1];
        qubits[i + 1] = outQubits[0];
    }
}

// Emits the kernel corresponding to `op`:
//  - `PPMeasurementOp`: measures `qubits[0]` and assigns the i1 to `measResult`.
//  - `PPRotationOp`: applies an RZ on `qubits[0]` with angle from `getRotationKind()`.
//  - `PPRotationArbitraryOp`: applies an RZ on `qubits[0]` with angle = 2 * arbitrary_angle.
//
//      PPR(theta, Z) = exp(-i * theta * Z)
//      RZ(phi)       = exp(-i * phi/2 * Z)
//      Therefore: phi = 2 * theta
void constructKernelOperation(SmallVector<Value> &qubits, Value &measResult, QECOpInterface op,
                              ConversionPatternRewriter &rewriter)
{
    if (isa<PPMeasurementOp>(op)) {
        auto measOp = buildMeasurementOp(qubits[0], rewriter);
        measResult = measOp.getMres();
        qubits[0] = measOp.getOutQubit();
    }
    else if (auto pprOp = dyn_cast<PPRotationOp>(op.getOperation())) {
        int16_t signedRk = static_cast<int16_t>(pprOp.getRotationKind());
        double rk = 2 * (llvm::numbers::pi / (static_cast<double>(signedRk)));
        qubits[0] = buildSingleQubitGate(qubits[0], "RZ", {rk}, rewriter).getOutQubits().front();
    }
    else if (auto pprArbitraryOp = dyn_cast<PPRotationArbitraryOp>(op.getOperation())) {
        Value angle = pprArbitraryOp.getArbitraryAngle();
        auto loc = pprArbitraryOp.getLoc();

        // Create constant 2.0 and multiply to get RZ angle
        auto two = rewriter.create<mlir::arith::ConstantOp>(loc, rewriter.getF64Type(),
                                                            rewriter.getF64FloatAttr(2.0));
        auto rzAngle = rewriter.create<mlir::arith::MulFOp>(loc, angle, two.getResult());

        // Create RZ gate with dynamic angle
        qubits[0] =
            buildSingleQubitGateWithDynamicParams(qubits[0], "RZ", {rzAngle.getResult()}, rewriter)
                .getOutQubits()
                .front();
    }
}

//===----------------------------------------------------------------------===//
//                       QEC Lowering Patterns
//===----------------------------------------------------------------------===//

// Lowers a QEC Pauli-product operation to an MBQC-style implementation.
//
// Steps:
//  - Conjugate qubits so the Pauli string is mapped to the Z basis.
//  - Accumulate parity onto the first qubit via a CNOT ladder.
//  - Emit the kernel:
//     * PPMeasurementOp: measure the first qubit, yielding an i1 SSA value.
//     * PPRotationOp: apply an RZ with angle derived from `getRotationKind()`.
//  - Uncompute by reversing the CNOT ladder and the conjugation.
//
// Replacement:
//  - PPMeasurementOp → replace with `[mres] ++ out_qubits`.
//  - PPRotationOp → replace with `out_qubits`.
//
// Preconditions:
//  - `op` implements `QECOpInterface` and provides `getInQubits()`.
//  - Insertion point is set to `op`.
//
// Returns success after replacing `op` with the produced SSA values.
//
// Circuit example: (PPR/PPM to list of gates lowering)
//  - PPR XX(π/4) [0, 1]: H(0) • H(1) • CNOT(1, 0) • RZ(π/2)   • CNOT(1, 0) • H(0) • H(1)
//  - PPR ZZ(π/8) [0, 1]:               CNOT(1, 0) • RZ(π/4)   • CNOT(1, 0)
//  - PPR YZ(π/8) [0, 1]: RotXZX(0)   • CNOT(1, 0) • RZ(π/4)   • CNOT(1, 0) • RotXZX(0)†
//  - PPM XX      [0, 1]: H(0) • H(1) • CNOT(1, 0) • Measure(0)• CNOT(1, 0) • H(0) • H(1)
//  - PPM ZZ      [0, 1]:               CNOT(1, 0) • Measure(0)• CNOT(1, 0)
//  - PPM YZ      [0, 1]: RotXZX(0)   • CNOT(1, 0) • Measure(0)• CNOT(1, 0) • RotXZX(0)†
//
// [[maybe_unused]] is used to suppress the warning about the function being unused.
//
[[maybe_unused]]
LogicalResult convertToMBQC(QECOpInterface op, ConversionPatternRewriter &rewriter)
{
    Value measResult;
    auto pauliString = extractPauliString(op);
    SmallVector<Value> qubits = op.getInQubits();

    // Diagonal operations
    constructPauliConjugationLayer(qubits, pauliString, /*isReverse=*/false, rewriter);

    // CNOT chain
    constructCNOTLadder(qubits, rewriter);

    // Kernel operation
    constructKernelOperation(qubits, measResult, op, rewriter);

    // Reverse CNOT chain
    constructReverseCNOTLadder(qubits, rewriter);

    // Reverse diagonal operations
    constructPauliConjugationLayer(qubits, pauliString, /*isReverse=*/true, rewriter);

    if (isa<PPMeasurementOp>(op)) {
        qubits.insert(qubits.begin(), measResult);
    }

    rewriter.replaceOp(op, qubits);

    return success();
}

template <typename TargetOp> struct PPRToMBQCLowering : public ConversionPattern {
    PPRToMBQCLowering(MLIRContext *context)
        : ConversionPattern(TargetOp::getOperationName(), 1, context)
    {
    }

    LogicalResult matchAndRewrite(Operation *op, ArrayRef<Value> operands,
                                  ConversionPatternRewriter &rewriter) const final
    {
        if (auto qecOp = dyn_cast<QECOpInterface>(op)) {
            return convertToMBQC(qecOp, rewriter);
        }
        return failure();
    }
};

using PPRotationOpLowering = PPRToMBQCLowering<qec::PPRotationOp>;
using PPRotationArbitraryOpLowering = PPRToMBQCLowering<qec::PPRotationArbitraryOp>;
using PPMeasurementOpLowering = PPRToMBQCLowering<qec::PPMeasurementOp>;

} // namespace

namespace catalyst {
namespace qec {

void populatePPRToMBQCPatterns(RewritePatternSet &patterns)
{
    patterns.add<PPRotationOpLowering>(patterns.getContext());
    patterns.add<PPRotationArbitraryOpLowering>(patterns.getContext());
    patterns.add<PPMeasurementOpLowering>(patterns.getContext());
}

} // namespace qec
} // namespace catalyst
