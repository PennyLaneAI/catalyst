// Copyright 2025 Xanadu Quantum Technologies Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <mlir/Dialect/Arith/IR/Arith.h>

#include "QEC/IR/QECDialect.h"
#include "QEC/Transforms/Patterns.h"
#include "QEC/Utils/PauliStringWrapper.h"
#include "Quantum/IR/QuantumOps.h"

using namespace mlir;
using namespace catalyst;
using namespace catalyst::quantum;
using namespace catalyst::qec;

namespace {

CustomOp buildCNOTGate(Value control, Value target, ConversionPatternRewriter &rewriter)
{
    return rewriter.create<quantum::CustomOp>(
        control.getLoc(),
        /*out_qubits=*/mlir::TypeRange({control.getType(), target.getType()}),
        /*out_ctrl_qubits=*/mlir::TypeRange({}),
        /*params=*/mlir::ValueRange(),
        /*in_qubits=*/mlir::ValueRange({control, target}),
        /*gate_name=*/"CNOT",
        /*adjoint=*/false,
        /*in_ctrl_qubits=*/mlir::ValueRange({}),
        /*in_ctrl_values=*/mlir::ValueRange());
}

CustomOp buildSingleQubitGate(Value qubit, StringRef gateName, ArrayRef<double> params,
                              ConversionPatternRewriter &rewriter)
{
    SmallVector<Value, 1> paramValues;
    auto f64Ty = rewriter.getF64Type();
    for (double p : params) {
        auto cst = rewriter.create<mlir::arith::ConstantOp>(qubit.getLoc(), f64Ty,
                                                            rewriter.getF64FloatAttr(p));
        paramValues.push_back(cst.getResult());
    }

    return rewriter.create<quantum::CustomOp>(qubit.getLoc(),
                                              /*out_qubits=*/mlir::TypeRange({qubit.getType()}),
                                              /*out_ctrl_qubits=*/mlir::TypeRange({}),
                                              /*params=*/mlir::ValueRange(paramValues),
                                              /*in_qubits=*/mlir::ValueRange({qubit}),
                                              /*gate_name=*/gateName,
                                              /*adjoint=*/false,
                                              /*in_ctrl_qubits=*/mlir::ValueRange({}),
                                              /*in_ctrl_values=*/mlir::ValueRange());
}

MeasureOp buildMeasurementOp(Value qubit, ConversionPatternRewriter &rewriter)
{
    return rewriter.create<quantum::MeasureOp>(qubit.getLoc(),
                                               /*mres=*/rewriter.getI1Type(),
                                               /*out_qubits=*/qubit.getType(),
                                               /*in_qubits=*/qubit,
                                               /*postselect=*/nullptr);
}

// Applies per-qubit conjugations that map the provided Pauli string to the Z
// basis. If `isReverse` is true, applies the inverse mapping.
void constructPauliConjugationLayer(SmallVector<Value> &qubits, SmallVector<StringRef> pauliString,
                                    bool isReverse, ConversionPatternRewriter &rewriter)
{
    // Apply the conjugation gate on the corresponding qubit index.
    // Expect the Pauli string length to match the number of qubits.
    size_t numQubits = qubits.size();

    for (size_t idx = 0; idx < numQubits; idx++) {
        switch (pauliString[idx].front()) {
        case 'X': {
            qubits[idx] =
                buildSingleQubitGate(qubits[idx], "Hadamard", {}, rewriter).getOutQubits().front();
            break;
        }
        case 'Y': {
            // These parameters values are generated by @convert_to_mbqc_gateset from PennyLane.
            // Currently, these params are hardcoded because there are only two possible values for
            // Y Pauli, and it would be tedious to write a function to generate them.
            // ─────RotXZX(11.33,0.00,2.80)────RZ(PHI/2)────RotXZX(1.23,0.00,9.76)────
            auto params = !isReverse ? std::array<double, 3>({11.33, 0.00, 2.80})
                                     : std::array<double, 3>({1.23, 0.00, 9.76});
            qubits[idx] = buildSingleQubitGate(qubits[idx], "RotXZX", params, rewriter)
                              .getOutQubits()
                              .front();
            break;
        }
        case 'I':
        case 'Z': {
            // No action needed for I/Z when mapping to Z-basis.
            break;
        }
        }
    }
}

// Applies a right-to-left CNOT ladder to accumulate parity onto `qubits[0]`.
void constructCNOTLadder(SmallVector<Value> &qubits, ConversionPatternRewriter &rewriter)
{
    size_t numQubits = qubits.size();
    for (size_t i = numQubits - 1; i > 0; i--) {
        auto outQubits = buildCNOTGate(qubits[i], qubits[i - 1], rewriter).getOutQubits();
        qubits[i] = outQubits[0];
        qubits[i - 1] = outQubits[1];
    }
}

// Reverses the CNOT ladder to uncompute parity accumulation.
void constructReverseCNOTLadder(SmallVector<Value> &qubits, ConversionPatternRewriter &rewriter)
{
    size_t numQubits = qubits.size();
    for (size_t i = 0; i + 1 < numQubits; i++) {
        auto outQubits = buildCNOTGate(qubits[i + 1], qubits[i], rewriter).getOutQubits();
        qubits[i] = outQubits[1];
        qubits[i + 1] = outQubits[0];
    }
}

// Emits the kernel corresponding to `op`:
//  - `PPMeasurementOp`: measures `qubits[0]` and assigns the i1 to `measResult`.
//  - `PPRotationOp`: applies an RZ on `qubits[0]` with angle from `getRotationKind()`.
void constructKernelOperation(SmallVector<Value> &qubits, Value &measResult, QECOpInterface op,
                              ConversionPatternRewriter &rewriter)
{
    if (isa<PPMeasurementOp>(op)) {
        auto measOp = buildMeasurementOp(qubits[0], rewriter);
        measResult = measOp.getMres();
        qubits[0] = measOp.getOutQubit();
    }
    else {
        int16_t signedRk = static_cast<int16_t>(op.getRotationKind());
        double rk = llvm::numbers::pi / (static_cast<double>(signedRk) / 2);
        qubits[0] = buildSingleQubitGate(qubits[0], "RZ", {rk}, rewriter).getOutQubits().front();
    }
}

//===----------------------------------------------------------------------===//
//                       QEC Lowering Patterns
//===----------------------------------------------------------------------===//

// Lowers a QEC Pauli-product operation to an MBQC-style implementation.
//
// Steps:
//  - Conjugate qubits so the Pauli string is mapped to the Z basis.
//  - Accumulate parity onto the first qubit via a CNOT ladder.
//  - Emit the kernel:
//     * PPMeasurementOp: measure the first qubit, yielding an i1 SSA value.
//     * PPRotationOp: apply an RZ with angle derived from `getRotationKind()`.
//  - Uncompute by reversing the CNOT ladder and the conjugation.
//
// Replacement:
//  - PPMeasurementOp → replace with `[mres] ++ out_qubits`.
//  - PPRotationOp → replace with `out_qubits`.
//
// Preconditions:
//  - `op` implements `QECOpInterface` and provides `getInQubits()`.
//  - Insertion point is set to `op`.
//
// Returns success after replacing `op` with the produced SSA values.
//
// LLVM_ATTRIBUTE_USED is used to suppress the warning about the function being unused.
LLVM_ATTRIBUTE_USED LogicalResult convertToMBQC(QECOpInterface op,
                                                ConversionPatternRewriter &rewriter)
{
    Value measResult;
    auto pauliString = extractPauliString(op);
    SmallVector<Value> qubits = op.getInQubits();

    // Diagonal operations
    constructPauliConjugationLayer(qubits, pauliString, /*isReverse=*/false, rewriter);

    // CNOT chain
    constructCNOTLadder(qubits, rewriter);

    // Kernel operation
    constructKernelOperation(qubits, measResult, op, rewriter);

    // Reverse CNOT chain
    constructReverseCNOTLadder(qubits, rewriter);

    // Reverse diagonal operations
    constructPauliConjugationLayer(qubits, pauliString, /*isReverse=*/true, rewriter);

    if (isa<PPMeasurementOp>(op)) {
        qubits.insert(qubits.begin(), measResult);
    }

    rewriter.replaceOp(op, qubits);

    return success();
}

template <typename TargetOp> struct PPRToMBQCLowering : public ConversionPattern {
    PPRToMBQCLowering(MLIRContext *context)
        : ConversionPattern(TargetOp::getOperationName(), 1, context)
    {
    }

    LogicalResult matchAndRewrite(Operation *op, ArrayRef<Value> operands,
                                  ConversionPatternRewriter &rewriter) const final
    {
        if (auto qecOp = dyn_cast<QECOpInterface>(op)) {
            return convertToMBQC(qecOp, rewriter);
        }
        return failure();
    }
};

using PPRotationOpLowering = PPRToMBQCLowering<qec::PPRotationOp>;
using PPMeasurementOpLowering = PPRToMBQCLowering<qec::PPMeasurementOp>;

} // namespace

namespace catalyst {
namespace qec {

void populatePPRToMBQCPatterns(RewritePatternSet &patterns)
{
    patterns.add<PPRotationOpLowering>(patterns.getContext());
    patterns.add<PPMeasurementOpLowering>(patterns.getContext());
}

} // namespace qec
} // namespace catalyst
