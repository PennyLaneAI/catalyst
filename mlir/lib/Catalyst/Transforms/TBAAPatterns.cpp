// Copyright 2024 Xanadu Quantum Technologies Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <algorithm>

#include "mlir/Analysis/SliceAnalysis.h"
#include "mlir/Conversion/LLVMCommon/MemRefBuilder.h"
#include "mlir/Conversion/LLVMCommon/Pattern.h"
#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/LLVMIR/FunctionCallUtils.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/PatternMatch.h"

#include "Catalyst/Transforms/TBAAUtils.h"

using namespace mlir;

namespace catalyst {

bool isFromExtractAlignedPointerAsIndexOp(Operation *op)
{
    // Returns true if the memref.store/load ops deal with memrefs coming from a
    // memref.extract_aligned_pointer_as_index op

    SetVector<Operation *> backwardSlice;
    BackwardSliceOptions options;
    // Upstream slice analysis fails if encounters a block argument in an op with
    // more than one region
    // https://github.com/llvm/llvm-project/blob/179d30f8c3fddd3c85056fd2b8e877a4a8513158/mlir/lib/Analysis/SliceAnalysis.cpp#L109
    options.omitBlockArguments = true;
    getBackwardSlice(op, &backwardSlice, options);
    bool found = std::find_if(backwardSlice.begin(), backwardSlice.end(), [](const Operation *op) {
                     return isa<memref::ExtractAlignedPointerAsIndexOp>(op);
                 }) != backwardSlice.end();
    return found;
}

bool isMemrefArgOfDeallocHelper(Operation *op)
{
    // Some memref.store and load ops are in the `dealloc_helper` function
    // generated by the --buffer--deallocation--pipeline.
    // `index` types on this function's arguments are pointers, not ints
    //
    // See https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/#generic-lowering
    //  * The generated function takes two MemRefs of indices and three MemRefs of
    //  * booleans as arguments:
    //  * The first argument A should contain the result of the
    //  * extract_aligned_pointer_as_index operation applied to the MemRefs to be deallocated
    //  * The second argument B should contain the result of the
    //  * extract_aligned_pointer_as_index operation applied to the MemRefs to be retained
    assert(isa<memref::LoadOp>(op) || isa<memref::StoreOp>(op));
    auto parentOp = dyn_cast<func::FuncOp>(op->getParentOp());
    if (!parentOp) {
        return false;
    }

    auto str = parentOp.getName();
    llvm::StringRef dellocRef = "dealloc_helper";
    if (!(str.compare(dellocRef) == 0)) {
        return false;
    }

    Value mem;
    if (isa<memref::LoadOp>(op)) {
        mem = dyn_cast<memref::LoadOp>(op).getMemref();
    }
    else if (isa<memref::StoreOp>(op)) {
        mem = dyn_cast<memref::StoreOp>(op).getMemref();
    }

    auto funcArgs = parentOp.getCallableRegion()->getArguments();
    auto memPos = std::find(funcArgs.begin(), funcArgs.end(), mem);
    if (std::distance(funcArgs.begin(), memPos) >= 2) {
        // Only the first two arguments to `dealloc_helper` are the memrefs we are looking for
        // Note that std::find returns end iterator if not found
        // so distance >=2 also covers the case for not found
        return false;
    }

    return true;
}

void setTag(mlir::Type baseType, catalyst::TBAATree *tree, mlir::MLIRContext *ctx,
            mlir::LLVM::AliasAnalysisOpInterface newOp)
{
    mlir::LLVM::TBAATagAttr tag;
    if (isa<IndexType>(baseType) || isa<IntegerType>(baseType)) {
        tag = tree->getTag("int");
        newOp.setTBAATags(ArrayAttr::get(ctx, tag));
    }
    else if (isa<FloatType>(baseType)) {
        if (baseType.isF32()) {
            tag = tree->getTag("float");
        }
        else if (baseType.isF64()) {
            tag = tree->getTag("double");
        }

        newOp.setTBAATags(ArrayAttr::get(ctx, tag));
    }
    else if (isa<MemRefType>(baseType)) {
        tag = tree->getTag("any pointer");

        newOp.setTBAATags(ArrayAttr::get(ctx, tag));
    }
}

template <typename... Types> bool isAnyOf(Type baseType) { return (isa<Types>(baseType) || ...); }

struct MemrefLoadTBAARewritePattern : public ConvertOpToLLVMPattern<memref::LoadOp> {
    using ConvertOpToLLVMPattern<memref::LoadOp>::ConvertOpToLLVMPattern;

    template <typename... Args>
    MemrefLoadTBAARewritePattern(catalyst::TBAATree &tree, Args &&...args)
        : ConvertOpToLLVMPattern(std::forward<Args>(args)...), tree(&tree){};

    LogicalResult matchAndRewrite(memref::LoadOp loadOp, memref::LoadOpAdaptor adaptor,
                                  ConversionPatternRewriter &rewriter) const override
    {
        auto type = loadOp.getMemRefType();
        auto baseType = type.getElementType();
        Value dataPtr = getStridedElementPtr(loadOp.getLoc(), type, adaptor.getMemref(),
                                             adaptor.getIndices(), rewriter);
        auto op = rewriter.replaceOpWithNewOp<LLVM::LoadOp>(
            loadOp, typeConverter->convertType(type.getElementType()), dataPtr, 0, false,
            loadOp.getNontemporal());

        // Index can be used as a pointer.
        if (isa<IndexType>(baseType) &&
            (isFromExtractAlignedPointerAsIndexOp(loadOp) || isMemrefArgOfDeallocHelper(loadOp))) {
            mlir::LLVM::TBAATagAttr tag = tree->getTag("any pointer");
            op.setTBAATags(ArrayAttr::get(loadOp.getContext(), tag));
        }
        else if (isAnyOf<IndexType, IntegerType, FloatType, MemRefType>(baseType)) {
            setTag(baseType, tree, loadOp.getContext(), op);
        }
        else {
            return failure();
        }
        return success();
    }

  private:
    catalyst::TBAATree *tree = nullptr;
};

struct MemrefStoreTBAARewritePattern : public ConvertOpToLLVMPattern<memref::StoreOp> {
    using ConvertOpToLLVMPattern<memref::StoreOp>::ConvertOpToLLVMPattern;

    template <typename... Args>
    MemrefStoreTBAARewritePattern(catalyst::TBAATree &tree, Args &&...args)
        : ConvertOpToLLVMPattern(std::forward<Args>(args)...), tree(&tree){};

    LogicalResult matchAndRewrite(memref::StoreOp storeOp, memref::StoreOpAdaptor adaptor,
                                  ConversionPatternRewriter &rewriter) const override
    {
        auto type = storeOp.getMemRefType();
        auto baseType = type.getElementType();

        Value dataPtr = getStridedElementPtr(storeOp.getLoc(), type, adaptor.getMemref(),
                                             adaptor.getIndices(), rewriter);
        auto op = rewriter.replaceOpWithNewOp<LLVM::StoreOp>(storeOp, adaptor.getValue(), dataPtr,
                                                             0, false, storeOp.getNontemporal());

        // Index can be used as a pointer.
        if (isa<IndexType>(baseType) && (isFromExtractAlignedPointerAsIndexOp(storeOp) ||
                                         isMemrefArgOfDeallocHelper(storeOp))) {
            mlir::LLVM::TBAATagAttr tag = tree->getTag("any pointer");
            op.setTBAATags(ArrayAttr::get(storeOp.getContext(), tag));
        }
        else if (isAnyOf<IndexType, IntegerType, FloatType, MemRefType>(baseType)) {
            setTag(baseType, tree, storeOp.getContext(), op);
        }
        else {
            return failure();
        }
        return success();
    }

  private:
    catalyst::TBAATree *tree = nullptr;
};

void populateTBAATagsPatterns(TBAATree &tree, LLVMTypeConverter &typeConverter,
                              RewritePatternSet &patterns)
{
    patterns.add<catalyst::MemrefLoadTBAARewritePattern>(tree, typeConverter);
    patterns.add<catalyst::MemrefStoreTBAARewritePattern>(tree, typeConverter);
}

} // namespace catalyst
